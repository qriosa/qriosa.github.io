<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Syzkaller部分功能点源码分析 | Ron's Blog</title><meta name="keywords" content="Fuzz,Syzkaller"><meta name="author" content="Ron"><meta name="copyright" content="Ron"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="新手基于目的导向对Syzkaller的源码阅读">
<meta property="og:type" content="article">
<meta property="og:title" content="Syzkaller部分功能点源码分析">
<meta property="og:url" content="https://lucxer.tech/2023/02/13/34.Syzkaller/index.html">
<meta property="og:site_name" content="Ron&#39;s Blog">
<meta property="og:description" content="新手基于目的导向对Syzkaller的源码阅读">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/google/syzkaller/raw/f325deb023e4e2fb9197004be1b3da738680429c/docs/process_structure.png?raw=true">
<meta property="article:published_time" content="2023-02-13T06:22:29.000Z">
<meta property="article:modified_time" content="2024-11-21T08:30:20.691Z">
<meta property="article:author" content="Ron">
<meta property="article:tag" content="Fuzz">
<meta property="article:tag" content="Syzkaller">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/google/syzkaller/raw/f325deb023e4e2fb9197004be1b3da738680429c/docs/process_structure.png?raw=true"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://lucxer.tech/2023/02/13/34.Syzkaller/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"KUPKZYGXJZ","apiKey":"c694052eee4849f0ddc6a25bc8e40d6c","indexName":"blog","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: true
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-11-21 16:30:20'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = '1'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}const fontSizeVal = saveToLocal.get('global-font-size')
if (fontSizeVal !== undefined) {
  document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
}})()</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">68</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://github.com/google/syzkaller/raw/f325deb023e4e2fb9197004be1b3da738680429c/docs/process_structure.png?raw=true)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Ron's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Syzkaller部分功能点源码分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-13T06:22:29.000Z" title="发表于 2023-02-13 14:22:29">2023-02-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-21T08:30:20.691Z" title="更新于 2024-11-21 16:30:20">2024-11-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/">模糊测试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>53分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="0x00-写在前面"><a href="#0x00-写在前面" class="headerlink" title="0x00 写在前面"></a>0x00 写在前面</h1><p>本文主要对 Syzkaller 的学习过程进行记录，其中不少内容都是来自个人对源码的研读。由于是目的导向性的，所以整个文本都以某种功能为需求，然后再找相关代码的实现进行记录的，因此可能并不适合新学者进行系统性的学习。</p>
<p>由于是初学者写的笔记，对 <code>golang</code> 也不是特别熟悉，基本就是能看懂，能简单改改的地步，所以可能有些谬误之处。</p>
<h1 id="0x01-coverage-检测方法"><a href="#0x01-coverage-检测方法" class="headerlink" title="0x01 coverage 检测方法"></a>0x01 coverage 检测方法</h1><p>该部分来自对 <a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/linux/coverage.md">coverage</a> 的整理和翻译。</p>
<p>Syzkaller 使用 <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/dev-tools/kcov.html">kcov</a> 来收集内核的覆盖率信息。kcov 将会探索每个被执行的基本块的地址，然后 Syzkaller 在运行时会使用 <code>binutils</code> (<code>objdump</code> , <code>nm</code> , <code>addr2line</code> , <code>readelf</code>) 中的工具来映射这些地址为源代码中的函数和 <code>lines</code> 。</p>
<h2 id="Binutils"><a href="#Binutils" class="headerlink" title="Binutils"></a>Binutils</h2><h3 id="readelf"><a href="#readelf" class="headerlink" title="readelf"></a>readelf</h3><p>使用 <code>readelf</code> 来获取虚拟内存偏移。具体使用的命令是：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -SW kernel_image</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-S</code> : 列举 kernel image 文件中的所有 section headers。</li>
<li><code>-W</code> : 每一行单独输出每个 section 的 header 。</li>
</ul>
<p>输出的数据大约是下面这个样子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">There are 59 section headers, starting at offset 0x3825258:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .text             PROGBITS        ffffffff81000000 200000 e010f7 00  AX  0   0 4096</span><br><span class="line">  [ 2] .rela.text        RELA            0000000000000000 23ff488 684720 18   I 56   1  8</span><br><span class="line">  [ 3] .rodata           PROGBITS        ffffffff82000000 1200000 2df790 00  WA  0   0 4096</span><br><span class="line">  [ 4] .rela.rodata      RELA            0000000000000000 2a83ba8 0d8e28 18   I 56   3  8</span><br><span class="line">  [ 5] .pci_fixup        PROGBITS        ffffffff822df790 14df790 003180 00   A  0   0 16</span><br><span class="line">  [ 6] .rela.pci_fixup   RELA            0000000000000000 2b5c9d0 004a40 18   I 56   5  8</span><br><span class="line">  [ 7] .tracedata        PROGBITS        ffffffff822e2910 14e2910 000078 00   A  0   0  1</span><br><span class="line">  [ 8] .rela.tracedata   RELA            0000000000000000 2b61410 000120 18   I 56   7  8</span><br><span class="line">  [ 9] __ksymtab         PROGBITS        ffffffff822e2988 14e2988 011b68 00   A  0   0  4</span><br><span class="line">  [10] ...</span><br></pre></td></tr></table></figure>
<p>Syzkaller 中的 <code>executor</code> 会将 PC 中的值截断保存为 <code>uint32</code> 的值，而后发送给 <code>syz-manager</code> 。<code>syz-manager</code> 将会使用 section header 中的信息来恢复计算偏移。Syzkaller 中只考虑 <code>Type</code> 为 <code>PROGBITS</code> 的 section header （这个字段是啥含义？为啥只考虑这个部分）。<code>Address</code> 字段表示一个 section 在内存中的虚拟地址。要求所有的 <code>PROGBITS</code> 的 section 具有相同的 32 位高地址 （<code>0xffff ffff</code>），这 32 位将用于进行偏移恢复。</p>
<h2 id="Reporting-coverage-data"><a href="#Reporting-coverage-data" class="headerlink" title="Reporting coverage data"></a>Reporting coverage data</h2><p><code>MakeReportGenerator</code> 这个玩意创建了一个数据库对象来进行报告。它需要目标数据，以及有关源文件和构建目录位置的信息。而构建数据库的第一步是从目标二进制文件中提取函数数据。</p>
<h3 id="nm"><a href="#nm" class="headerlink" title="nm"></a>nm</h3><p><code>nm</code> 是用于处理 kernel 中每个函数的地址和大小的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm -Ptx kernel_image</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-P</code> - 使用便携的输出格式（标准输出</li>
<li><code>-tx</code> - 以 hex 的格式写数字</li>
</ul>
<p>输出数据大概是下面的样子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tracepoint_module_nb d ffffffff84509580 0000000000000018</span><br><span class="line">...</span><br><span class="line">udp_lib_hash t ffffffff831a4660 0000000000000007</span><br></pre></td></tr></table></figure>
<ul>
<li>第一列是符号的名字。</li>
<li>第二列是它的类型（<code>text section</code> , <code>data section</code> , <code>debugging symbol</code> , <code>undefined</code> , <code>zero-init section</code> , etc）</li>
<li>第三列是它 hex 形式的符号值。</li>
<li>第四列是它的大小。在 Syzkaller 中大小总是四舍五入到 16。</li>
</ul>
<p>对于覆盖率报告， Syzkaller 只关注于代码段（<code>code section</code>），所以会对 <code>nm</code> 的输出进行过滤，只要类型是 <code>t</code> or <code>T</code> 的符号。最终的结果是一个使用符号作为键，使用符号的起始和终止地址为值的字典。这个数据将用于覆盖数据到符号（函数）的映射。需要此步骤来查明是否调用了某些函数。</p>
<h2 id="Object-Dump-and-Symbolize"><a href="#Object-Dump-and-Symbolize" class="headerlink" title="Object Dump and Symbolize"></a>Object Dump and Symbolize</h2><p>为了给 Syzkaller 提供必要的信息用于捕获覆盖率信息，需要对编译器进行插桩，让其在编译阶段在每个基本块生成的时候，插入 <code>__sanitizer_cov_trace_pc</code> 调用。该调用可以作为一个锚点指令，返回覆盖的代码的行数（backtrack the covered code lines）。</p>
<h3 id="objdump"><a href="#objdump" class="headerlink" title="objdump"></a>objdump</h3><p><code>objdump</code> 被用于处理内核镜像中每个调用 <code>__sanitizer_cov_trace_pc</code> 时的 PC 的值。（这时的 PC 值就是下一个要执行的指令的地址，而这个又是我们给每个基本块中插入的，那这样不就捕获到了每个被执行的基本块的地址了吗？）这些 PC 值表示内核映像中内置的所有代码。将 kcov 导出的 PC 值与这些值进行比较以确定覆盖率。（我不明白，不相信kcov？还是不相信自己的插桩？这个做法还会有什么错的情况吗？）</p>
<p>内核 image 可以使用下面的命令反汇编。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d --no-show-raw-insn kernel_image</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-d</code> - 反汇编可执行代码块</li>
<li><code>-no-show-raw-insn</code> - 防止在符号反汇编的同时打印十六进制</li>
</ul>
<p>部分输出大概长这个样子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">ffffffff81000f41:	callq  ffffffff81382a00 &lt;__sanitizer_cov_trace_pc&gt;</span><br><span class="line">ffffffff81000f46:	lea    -0x80(%r13),%rdx</span><br><span class="line">ffffffff81000f4a:	lea    -0x40(%r13),%rsi</span><br><span class="line">ffffffff81000f4e:	mov    $0x1c,%edi</span><br><span class="line">ffffffff81000f53:	callq  ffffffff813ed680 &lt;perf_trace_buf_alloc&gt;</span><br><span class="line">ffffffff81000f58:	test   %rax,%rax</span><br><span class="line">ffffffff81000f5b:	je     ffffffff8100110e &lt;perf_trace_initcall_finish+0x2ae&gt;</span><br><span class="line">ffffffff81000f61:	mov    %rax,-0xd8(%rbp)</span><br><span class="line">ffffffff81000f68:	callq  ffffffff81382a00 &lt;__sanitizer_cov_trace_pc&gt;</span><br><span class="line">ffffffff81000f6d:	mov    -0x40(%r13),%rdx</span><br><span class="line">ffffffff81000f71:	mov    0x8(%rbp),%rsi</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>从这个输出来看，覆盖率 trace 调用时被标记来判别可执行区块的起始地址的。（从这个输出覆盖跟踪调用被识别以确定可执行块地址的开始）。（From this output coverage trace calls are identified to determine the start of the executable block addresses:）（我的理解是，应该是说上面这一堆中，我们应该关注的有用的信息是下面这两行）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffffffff81000f41:	callq  ffffffff81382a00 &lt;__sanitizer_cov_trace_pc&gt;</span><br><span class="line">ffffffff81000f68:	callq  ffffffff81382a00 &lt;__sanitizer_cov_trace_pc&gt;</span><br></pre></td></tr></table></figure>
<h3 id="addr2line"><a href="#addr2line" class="headerlink" title="addr2line"></a>addr2line</h3><p><code>addr2line</code> 被用于映射 kcov 发现的 PC 值，然后被 <code>objdump</code> 进一步处理成源码文件和行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addr2line -afip -e kernel_image</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-afip</code> - 显示地址、函数名字和 unwind ilined functions 和适合人类读。</li>
<li><code>-e</code> - 是用于指定可执行文件，而不是使用默认值 <code>a.out</code>。</li>
</ul>
<p><code>addr2line</code> 从标准输入中读取 16 进制地址，然后在标准输出打印每个地址的文件名、函数和行号。</p>
<p>使用示例，其中 <code>&gt;&gt;</code> 表示询问， <code>&lt;&lt;</code> 表示 <code>addr2line</code> 的响应：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; ffffffff8148ba08</span><br><span class="line">&lt;&lt; 0xffffffff8148ba08</span><br><span class="line">&lt;&lt; generic_file_read_iter</span><br><span class="line">&lt;&lt; /home/user/linux/mm/filemap.c:2363</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是我实际实测发现输出的都是 ?? 这样的样子，我还以为是没有符号表，网上查了查，好像是这个命令只接受相对偏移而不是一个绝对地址，应该减去起始地址。但是我还是只能整出来这些 ??</p>
</blockquote>
<p>最终的目标是构建一个 <code>frames</code> 的哈希表，键是 PC 值，值是一个 <code>frame array</code> 由下列的信息组成：</p>
<ul>
<li><code>PC</code> - 64 位的 program counter 的值，与键一样。</li>
<li><code>Func</code> - 这个 frame 属于的函数的名字</li>
<li><code>File</code> - 文件名（函数或者 frame 所属的）</li>
<li><code>Line</code> - PC 映射所对应的一个文件中的行号</li>
<li><code>Inline</code> - 布尔值 inlining 信息。由于 inlining 的存在，可能会有很多个 frame 能够被连接到同一个 PC 值上。</li>
</ul>
<h2 id="Create-report"><a href="#Create-report" class="headerlink" title="Create report"></a>Create report</h2><p>一旦 frames 和函数地址范围的数据库构建成功后，下一步就是去确定程序（program）的覆盖率。每个 program 在这里就是一系列 PC 值。此时每个函数的地址范围都是已知的，所以很容易通过简单迭代比较 PC 中的值和函数的范围来判断到底是哪个函数被调用了。此外基于以 PC 值为键的 frame 哈希表中，覆盖率信息被聚集到了源文件上。这些被称为 <code>coveredPCs</code> 。覆盖率结果并不是基于行的而是基于基本块的。最终的结果是保存在如下的文件结构中。</p>
<ul>
<li><code>lines</code> - 文件中被覆盖的行。（lines coverd in the file</li>
<li><code>totalPCs</code> - 这个文件中总共被标注的 PC </li>
<li><code>coveredPCS</code> - 这个 program 执行过程中被执行了的 PC</li>
<li><code>totalInline</code> - 被映射到 inlined frames 上的 PC 的数量</li>
<li><code>coveredInline</code> - 在这个 program 执行的过程中被映射到 inlined frames 上的 PC</li>
</ul>
<p>问题：不是很懂这个文件开始保存的时机或者说这些 PC 拿到时候的时机。</p>
<h1 id="0x02-go-func-amp-feature"><a href="#0x02-go-func-amp-feature" class="headerlink" title="0x02 go func &amp; feature"></a>0x02 go func &amp; feature</h1><p>对一些 go 的语法和函数进行一个解释, syzkaller 中关于随机相关的定义在  <a href="/syzkaller/prog/rand.go">prog/rand.go:line 561</a> 。 </p>
<p>go 疑似函数命名必须驼峰;不用的变量，例如遍历字典时需要使用 _ 不然就会报错</p>
<h2 id="r-Intn-n"><a href="#r-Intn-n" class="headerlink" title="r.Intn(n)"></a>r.Intn(n)</h2><p>每次调用 <code>r.Intn(n)</code> 是重新随机执行，返回一个 <code>[0, n)</code> 中的整数。参考自: <a target="_blank" rel="noopener" href="https://pkg.go.dev/math/rand#example-package-Rand">link</a> .</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Intn, Int31n, and Int63n limit their output to be &lt; n.</span></span><br><span class="line"><span class="comment">// They do so more carefully than using r.Int()%n.</span></span><br><span class="line">r.Intn(<span class="number">10</span>) <span class="comment">// 返回一个 -1 &lt; x &lt; 10 的整数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次调用都是重新进行随机</span></span><br><span class="line">show(<span class="string">&quot;Intn(10)&quot;</span>, r.Intn(<span class="number">10</span>), r.Intn(<span class="number">10</span>), r.Intn(<span class="number">10</span>))</span><br><span class="line"><span class="comment">// Intn(10)    1                   2                   5</span></span><br></pre></td></tr></table></figure>
<h2 id="r-oneOf-n"><a href="#r-oneOf-n" class="headerlink" title="r.oneOf(n)"></a>r.oneOf(n)</h2><p>每次调用 <code>r.oneOf(n)</code> 是重新随机执行，返回一个 <code>[0, n)</code> 中的整数是否是 <code>0</code> ，即 以 <code>1/n</code> 的概率返回 <code>true</code> 。<a target="_blank" rel="noopener" href="https://www.lambdatest.com/automation-testing-advisor/golang/methods/syzkaller_go.prog.oneOf">link</a> .</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显然这个就是以 1/n 的概率返回 true ， n 越大 概率越小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *randGen)</span></span> oneOf(n <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.Intn(n) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="r-nOutOf-n-oufOf"><a href="#r-nOutOf-n-oufOf" class="headerlink" title="r.nOutOf(n, oufOf)"></a>r.nOutOf(n, oufOf)</h2><p>每次调用 <code>r.nOutOf(n, outOf)</code> 是重新执行，以 <code>n/outOf</code> 的概率返回 <code>true</code> 。 <a target="_blank" rel="noopener" href="https://www.lambdatest.com/automation-testing-advisor/golang/methods/syzkaller_go.prog.NOutOf#line:134">link</a> .</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r.nOutOf(n, outOf) 以 n/outOf 的概率返回 true</span></span><br><span class="line"><span class="comment">// nOutOf returns true n out of outOf times.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *randGen)</span></span> nOutOf(n, outOf <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="comment">// line: 354</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span> || n &gt;= outOf &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;bad probability&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    v := r.Intn(outOf)</span><br><span class="line">    <span class="keyword">return</span> v &lt; n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="r-biasedRand-n-k"><a href="#r-biasedRand-n-k" class="headerlink" title="r. biasedRand(n, k)"></a>r. biasedRand(n, k)</h2><p>每次调用 <code>biasedRand(n, k)</code> 返回一个 <code>[1,n)</code> 中的值，但是返回 <code>n-1</code> 的概率是 <code>0</code> 的 <code>k</code> 倍。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// biasedRand returns a random int in range [0..n),</span></span><br><span class="line"><span class="comment">// probability of n-1 is k times higher than probability of 0.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *randGen)</span></span> biasedRand(n, k <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	nf, kf := <span class="type">float64</span>(n), <span class="type">float64</span>(k)</span><br><span class="line">	rf := nf * (kf/<span class="number">2</span> + <span class="number">1</span>) * r.Float64()</span><br><span class="line">	bf := (<span class="number">-1</span> + math.Sqrt(<span class="number">1</span>+<span class="number">2</span>*kf*rf/nf)) * nf / kf</span><br><span class="line">	<span class="keyword">return</span> <span class="type">int</span>(bf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Sort-Search-int-func"><a href="#Sort-Search-int-func" class="headerlink" title="Sort.Search(int, func)"></a>Sort.Search(int, func)</h2><p>该函数 Search uses binary search to find and return the smallest index i in [0, n) at which f(i) is true,</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Search</span><span class="params">(n <span class="type">int</span>, f <span class="keyword">func</span>(<span class="type">int</span>)</span></span> <span class="type">bool</span>) <span class="type">int</span></span><br></pre></td></tr></table></figure>
<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>实测 <code>go</code> 的 <code>switch</code> 会自动 <code>break</code> 。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    opt := <span class="number">1</span></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> opt == <span class="number">1</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> opt == <span class="number">2</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;default&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行之后会只打印 <code>1</code> 而不会有后面的值。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go run test.go</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h1 id="0x03-mutation-规则"><a href="#0x03-mutation-规则" class="headerlink" title="0x03 mutation 规则"></a>0x03 mutation 规则</h1><p>对 Syzkaller 的具体变异规则的简单分析。</p>
<h2 id="变异模式"><a href="#变异模式" class="headerlink" title="变异模式"></a>变异模式</h2><p>其实就是以一定的概率选择下面的变异模式：</p>
<ol>
<li><p>squashAny</p>
<p> 随机选择 <code>p</code> 中一个复杂指针并将其参数压缩为 <code>ANY</code>。随后，如果 <code>ANY</code> 包含 <code>blob</code>，则变异一个随机 <code>blob</code>。</p>
<p> 我感觉就是挑一个复杂的指针变异其中的某一个参数即可。</p>
<ul>
<li>如果 <code>p</code> 中维护的复杂指针数组 (<code>complexPtrs</code>) 是空的，直接退出，变异失败。</li>
<li>否则随机在其中选择一个成为 <code>ptr</code> ，如果不幸选中的 <code>ptr</code> 所属的 <code>call</code> 不可变异，则直接退出，变异失败。</li>
<li>如果当前 <code>ptr.arg</code> 没有任何指针，则主动调用 <code>squashPtr</code> 将其压缩成指针。</li>
<li>然后对 <code>ptr</code> 中的数据参数和相应基址分别压缩到两个数组中。如果发现最后 <code>blob</code> 数组为空，直接退出，变异失败。</li>
<li>然后需要在对 <code>blob</code> 进行变异前进行分析，不然可能因为这个变异引入越界，导致分析过程越界报错。</li>
<li>然后对 <code>blob</code> 中随机选择一个参数来进行数据变异，最后返回变异成功。</li>
</ul>
</li>
</ol>
<ol>
<li><p>splice</p>
<ul>
<li><p>如果当前种子库为空、或当前 <code>p</code> 一个 <code>call</code> 都没有、或当前 <code>p</code> 拥有足够数量的 <code>call</code> ，则直接退出，变异失败。</p>
</li>
<li><p>从当前种子库中随机选择一个 <code>p0</code> ，然后在当前 <code>p</code> 中随机选一个位置 <code>idx</code>。</p>
</li>
<li><p>将 <code>p0</code> 插入到 <code>p</code> 中 <code>idx</code> 前面，组合成一个超级大的 <code>p1</code> ，<code>p1=p[:idx]+p0+p[idx:]</code>。</p>
</li>
<li><p>然后将 <code>p1</code> 中的 <code>call</code> 从末尾开始一个一个进行移除，直到 <code>p1</code> 中的 <code>call</code> 的数量刚好够 <code>ncall</code> 。</p>
</li>
</ul>
</li>
</ol>
<pre><code>感觉有可以优化的空间，如果太长了可以直接计算填满所缺的长度，然后切片就好了啊，为啥要无脑拼接，然后一一移除。
</code></pre><ol>
<li><p>insertCall</p>
<ul>
<li><p>如果程序已经有不少于 <code>ncall</code> 个<code>call</code> 了，则直接退出，变异失败。</p>
</li>
<li><p>在现有的 <code>p</code> 中随机选择一个位置（偏向于现有 <code>p</code> 的末尾，末尾的概率是开头的 <code>5</code> 倍），在其前方插入一个新生成的 <code>call</code> （通过调用 <code>generateCall</code> 来生成）。</p>
</li>
<li><p>若插入之后 <code>p</code> 中 <code>call</code> 的数量超过了 <code>ncall</code> ，则会主动调用 <code>RemoveCall</code> 移除刚才选中的那个 <code>call</code> 。（感觉怎么都不会走到这一步呀，前面明明只有小于时才会插入一个 <code>call</code> 那最多也是等于，怎会大于呢？</p>
</li>
</ul>
</li>
<li><p>mutateArg</p>
<p> 随机选择一个 <code>call</code> 的参数进行变异。</p>
<ul>
<li>如果当前 <code>p</code> 一个参数都没有，直接退出，变异失败。</li>
<li>基于 <code>call</code> 的参数的复杂性来选择一个 <code>call</code> ，这里似乎没有随机，总会选到当前 <code>p</code> 中参数最复杂的 <code>call</code> ，不同类型的参数会有一个计算规则，总之是可以计算得到一个浮点数的，然后最后加起来排序即可。如果所有的 <code>call</code> 都没有参数，那么直接退出，变异失败。</li>
<li>如果不幸选中的这个 <code>call</code> 是不能进行变异的，直接退出，变异失败。</li>
<li>然后开启一个循环，退出条件 （依据类型进行参数变异成功 and 1/3 的概率）</li>
<li>调用 <a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/5e63325073278d3f6b18c4990fab94a64a878e29/prog/analysis.go#L28">analyze</a> 根据选择表、种子库、<code>p</code> 、选中的 <code>call</code> 进行分析得到状态 <code>s</code> 。</li>
<li>然后调用 <code>(*Target)mutateArg</code> 真实进行参数变异，根据参数的类型选择实现设计好的变异策略。然后还会维护好上下文中的基地址不能变。</li>
<li><code>(*Target)mutateArg</code> 变异得到一串 <code>calls</code> 。</li>
<li>然后将变异得到的 <code>calls</code> 插入到前面选中的 <code>call</code> 前面。如果插入后过长了（大于 <code>ncall</code>），就开始对一个一个去移除 <code>p</code> 中的 <code>call</code> 直到等于 <code>ncall</code> 。</li>
<li>然后判断 一些不应该出现的异常情况后，返回变异成功。</li>
</ul>
</li>
<li><p>removeCall</p>
<ul>
<li>如果当前 <code>p</code> 是空的，则直接退出，变异失败。</li>
<li>否则从 <code>p</code> 中随机选择一个 <code>idx</code> ，然后主动调用 <code>RemoveCall</code> 移除。</li>
</ul>
</li>
</ol>
<h2 id="具体变异过程"><a href="#具体变异过程" class="headerlink" title="具体变异过程"></a>具体变异过程</h2><p>在源码 <a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/5e63325073278d3f6b18c4990fab94a64a878e29/prog/mutation.go#L26">/prog/mutation.go#L26</a> 可以找到和变异相关的函数。</p>
<p>当调用函数 <code>Mutate</code> 后会传入相关的一些必要的参数对当前的prog进行变异，该部分描述的是对一个prog进行的最外层的粗粒度的5种变异手法，这5种变异中除了<code>mutateArg</code> 和 <code>squashAny</code> 的选择有一定的设计外，其余的都是简单的随机法则 ，只保证不会少于0个，不会多于 ncall个和不会出现黑名单中的syscall。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mutate program p.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// p:           The program to mutate.</span></span><br><span class="line"><span class="comment">// rs:          Random source.</span></span><br><span class="line"><span class="comment">// ncalls:      The allowed maximum calls in mutated program.</span></span><br><span class="line"><span class="comment">// ct:          ChoiceTable for syscalls.</span></span><br><span class="line"><span class="comment">// noMutate:    Set of IDs of syscalls which should not be mutated.</span></span><br><span class="line"><span class="comment">// corpus:      The entire corpus, including original program p.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Prog)</span></span> Mutate(rs rand.Source, ncalls <span class="type">int</span>, ct *ChoiceTable, noMutate <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>, corpus []*Prog) &#123;</span><br><span class="line">	r := newRand(p.Target, rs) <span class="comment">// 初始化一个随机相关的玩意</span></span><br><span class="line">	<span class="keyword">if</span> ncalls &lt; <span class="built_in">len</span>(p.Calls) &#123; <span class="comment">// 变异后的prog的长度至少是当前还没变异的prog的长度（不明白</span></span><br><span class="line">		ncalls = <span class="built_in">len</span>(p.Calls)</span><br><span class="line">	&#125;</span><br><span class="line">	ctx := &amp;mutator&#123; <span class="comment">// 维护变异相关上下文</span></span><br><span class="line">		p:        p,        <span class="comment">// The program to mutate.</span></span><br><span class="line">		r:        r,        <span class="comment">// The randGen instance.</span></span><br><span class="line">		ncalls:   ncalls,   <span class="comment">// The allowed maximum calls in mutated program.</span></span><br><span class="line">		ct:       ct,       <span class="comment">// ChoiceTable for syscalls.</span></span><br><span class="line">		noMutate: noMutate, <span class="comment">// Set of IDs of syscalls which should not be mutated.</span></span><br><span class="line">		corpus:   corpus,   <span class="comment">// The entire corpus, including original program p.</span></span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 开始循环，退出条件为 （变异成功 and prog 长度不为0 and 1/3 的概率），否则继续进行</span></span><br><span class="line">	<span class="keyword">for</span> stop, ok := <span class="literal">false</span>, <span class="literal">false</span>; !stop; stop = ok &amp;&amp; <span class="built_in">len</span>(p.Calls) != <span class="number">0</span> &amp;&amp; r.oneOf(<span class="number">3</span>) &#123; </span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> r.oneOf(<span class="number">5</span>):        <span class="comment">// 以 1/5 的概率选择这个模式</span></span><br><span class="line">			<span class="comment">// Not all calls have anything squashable,</span></span><br><span class="line">			<span class="comment">// so this has lower priority in reality.</span></span><br><span class="line">			ok = ctx.squashAny() <span class="comment">// </span></span><br><span class="line">		<span class="keyword">case</span> r.nOutOf(<span class="number">1</span>, <span class="number">100</span>): <span class="comment">// 在剩下的情况中， 以 1/100 的概率选择这个模式</span></span><br><span class="line">			ok = ctx.splice() <span class="comment">// 在corpus中随机挑一个插入当前prog的随机一个位置</span></span><br><span class="line">		<span class="keyword">case</span> r.nOutOf(<span class="number">20</span>, <span class="number">31</span>): <span class="comment">// 在剩下的情况中， 以 2/3 的概率选择这个模式</span></span><br><span class="line">			ok = ctx.insertCall() <span class="comment">// 倾向于靠近prog的后段插入一个syscall</span></span><br><span class="line">		<span class="keyword">case</span> r.nOutOf(<span class="number">10</span>, <span class="number">11</span>): <span class="comment">// 在剩下的情况中， 以 9/10 的概率选择这个模式</span></span><br><span class="line">			ok = ctx.mutateArg()</span><br><span class="line">		<span class="keyword">default</span>: <span class="comment">// 最后剩下的情况就是选择这个模式</span></span><br><span class="line">			ok = ctx.removeCall() <span class="comment">// 随机移除一个 syscall</span></span><br><span class="line">		&#125; </span><br><span class="line">    <span class="comment">// 所以总的来说，真实的概率就是 </span></span><br><span class="line">    <span class="comment">// squashAny:  1000/5000  =  0.2000, </span></span><br><span class="line">    <span class="comment">// splice:       40/5000  =  0.0080,</span></span><br><span class="line">    <span class="comment">// insertCall: 2640/5000  =  0.5280,</span></span><br><span class="line">    <span class="comment">// mutateArg:  1188/5000  =  0.2376,</span></span><br><span class="line">    <span class="comment">// removeCall:  132/5000  =  0.0264,</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 简单排个序</span></span><br><span class="line">    <span class="comment">// splice:       40/5000  =  0.0080,</span></span><br><span class="line">    <span class="comment">// removeCall:  132/5000  =  0.0264,  </span></span><br><span class="line">    <span class="comment">// squashAny:  1000/5000  =  0.2000, </span></span><br><span class="line">    <span class="comment">// mutateArg:  1188/5000  =  0.2376, </span></span><br><span class="line">    <span class="comment">// insertCall: 2640/5000  =  0.5280,    </span></span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	p.sanitizeFix()   <span class="comment">// </span></span><br><span class="line">	p.debugValidate() <span class="comment">// 进行 debug 验证</span></span><br><span class="line">	<span class="keyword">if</span> got := <span class="built_in">len</span>(p.Calls); got &lt; <span class="number">1</span> || got &gt; ncalls &#123; <span class="comment">// 长度如果是 0 应该是没法退出前面的 for 的</span></span><br><span class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;bad number of calls after mutation: %v, want [1, %v]&quot;</span>, got, ncalls))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="mutateArg-规则"><a href="#mutateArg-规则" class="headerlink" title="mutateArg 规则"></a>mutateArg 规则</h3><p>当选择 <code>mutateArg</code> 模式时，会随机变异一个系统调用的参数。具体实施时：</p>
<ol>
<li>如果当前 prog 长度为 0 ，直接返回变异失败。</li>
<li>根据当前 prog 中的系统调用的参数的复杂性计算一个优先级，然后基于优先级随机选择一个系统调用，此时选择不会忽略特殊系统调用。某个参数的优先级计算规则是根据 <a href="#参数变异优先级">参数变异优先级</a> 进行。<ol>
<li>某一个系统调用的某一个参数的优先数据与其类型相关，有一个类型优先级计算规则。</li>
<li>某一个系统调用的优先级理论上等于其所有参数的优先级之和。但是会在扫描到其含有某些特殊类型的参数的某些条件时提前终止对后续参数的扫描，从而提前得到当前系统调用的优先级。</li>
<li>当扫描完，得知所有的系统调用都没有参数时，返回 -1，使得上层变异返回变异失败。</li>
<li>否则基于 prog 中每个系统调用的优先级随机返回一个系统调用下标。</li>
</ol>
</li>
<li>然后开始迭代变异，退出条件为变异成功并且1/3的概率。<ol>
<li>每次迭代重新收集选中的系统调用 c 的参数信息。</li>
<li>然后对当前 prog 中的状态信息进行分析，但是会忽略c及其之后的系统调用导致的状态中的 resources 的改变。</li>
<li>基于 c 的参数的优先级随机选择一个参数进行参数变异。参数变异则是根据 <a href="#变异规则按类型">变异规则按类型</a> 的变异规则进行 。</li>
<li>如果变异失败则回到迭代开始处。</li>
<li>否则变异成功则将变异新生成的 calls 插入到原 prog 中 c 之前的位置，并将插入后超过最大长度限制的 syscall 从末尾处移除。</li>
<li>验证移除之后的prog中长度必须有效，且 idx 对应的位置还应该是 c，不然就 panic。（如果变异生成的 calls 实际上只有一个 call 的话，只有可能被选中的 c 在原 prog 中位于最后并且 prog 长度达到了最长，才会导致原有的 c 被移除，然后才会报错这个才对。</li>
</ol>
</li>
</ol>
<h3 id="squashAny-规则"><a href="#squashAny-规则" class="headerlink" title="squashAny 规则"></a>squashAny 规则</h3><blockquote>
<p>// Picks a random complex pointer and squashes its arguments into an ANY.<br>// Subsequently, if the ANY contains blobs, mutates a random blob.</p>
</blockquote>
<p>当选择 <code>squashAny</code> 模式时，会随机选择一个复杂指针，然后将其参数压缩成 ANY，随后，如果 ANY 包含了多个 blob，则随机选择一个 blob 来进行变异。</p>
<p>复杂指针来源于定义在 <code>prog/any.go</code> 中的 <code>prog.complexPtrs()</code> 该函数会遍历当前 <code>prog</code> 的每一个系统调用的每一个参数，然后依据一定的规则判定某个参数是否是复杂指针。</p>
<p>例如下面的这些就不是复杂指针：</p>
<ul>
<li>参数返回值为空。</li>
<li>参数方向不是 in。</li>
<li>指针类型。</li>
</ul>
<p>下面的类型是复杂指针：</p>
<ul>
<li>参数本身就是一个指针类型并且指向任何数组。</li>
<li>union类型并且field大于5。</li>
<li>有长度的结构体类型。</li>
</ul>
<h2 id="参数变异优先级"><a href="#参数变异优先级" class="headerlink" title="参数变异优先级"></a>参数变异优先级</h2><p>在 Syzkaller(<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/commits/f325deb023e4e2fb9197004be1b3da738680429c">f325deb0</a>) 版本中，mutation.go 中的函数 <code>getMutationPrio</code> 对变异优先级有如下的注释。</p>
<blockquote>
<p>// TODO: find a way to estimate optimal priority values.<br>// Assign a priority for each type. The boolean is the reference type and it has<br>// the minimum priority, since it has only two possible values.</p>
</blockquote>
<p>首先定义了三个全局变量，用于描述优先级的范围</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	maxPriority = <span class="type">float64</span>(<span class="number">10</span>)</span><br><span class="line">	minPriority = <span class="type">float64</span>(<span class="number">1</span>)</span><br><span class="line">	dontMutate  = <span class="type">float64</span>(<span class="number">0</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>整型，不会停止迭代</p>
<ul>
<li>对于没有数值范围的或者范围不超过 256 的整型而言，其底层数据类型的位数越多优先级越高(最多64位)。 <code>bitSize+0.1*maxPriority</code> 。</li>
<li>对于有范围的，则根据范围大小而定优先级。<ul>
<li>范围为 0 优先级就是 0， 范围是 1 优先级就是 <code>minPriority</code> 。</li>
<li>范围不超过 15 的，假设认为是与 FlagsType 相当的，因为大多数 syscall 的可能的 flag 是小于15的范围的。所以将会去尝试所有的值。具体做法，优先级与范围大小成比例。在阈值之后，优先级是恒定的。 <code>min(size/3, 0.9)*maxPriority</code> 。</li>
<li>范围不超过 256 的，才会被认定有范围，因为这个是一个字节最多能表示的范围。优先级恒定 <code>maxPriority</code> 。</li>
</ul>
</li>
</ul>
</li>
<li><p>结构体类型</p>
<ul>
<li>如果这个结构体是应该被忽略的或者不特殊，则返回不变异 <code>dontMutate</code> ，并不停止迭代。</li>
<li>否则则返回最高优先级，且停止迭代。</li>
</ul>
</li>
<li><p>枚举类型（<code>UnionType</code>） </p>
<ul>
<li>如果这个类型应该被忽略或者（不特殊并且只有一个 field） 则返回不变异 <code>dontMutate</code> ，并不停止迭代。</li>
<li>否则如果只是不特殊但是又多个field，则希望变异枚举类型本身和当前选项的值。返回最高优先级，并不停止迭代。</li>
<li>否则就是特殊的，那就直接返回最高优先级，同时停止迭代。</li>
</ul>
</li>
<li><p>flag类型（FlagsType），不会停止迭代</p>
<p>与前面小范围整型一样，根据flag的大小正相关优先级。返回 <code>min(size/3, 0.9)*maxPriority</code> ，但是如果有 <code>BitMask</code> 则会再加一个 <code>0.1*maxPriority</code>。</p>
</li>
<li><p>指针类型（PtrType），不会停止迭代</p>
<ul>
<li>如果是特殊的指针，则返回不变异。（TODO，认为应该进行变异，但是还没有相应的代码）</li>
<li>否则返回  <code>0.3*maxPriority</code> 。</li>
</ul>
</li>
<li><p>常量类型（ConstType），返回不变异，不会停止迭代。</p>
</li>
<li><p>CsumType，自定义类型？</p>
<ul>
<li>返回不变异，不会停止迭代。</li>
</ul>
</li>
<li><p>ProcType？</p>
<ul>
<li>返回 <code>0.5*maxPriority</code>，不会停止迭代。</li>
</ul>
</li>
<li><p>资源类型（ResourceType）</p>
<ul>
<li>返回 <code>0.5*maxPriority</code>，不会停止迭代。</li>
</ul>
</li>
<li><p>虚拟页？（VmaType）</p>
<ul>
<li>返回 <code>0.5*maxPriority</code>，不会停止迭代。</li>
</ul>
</li>
<li><p>长度类型（LenType）</p>
<ul>
<li>返回 <code>0.5*maxPriority</code>，不会停止迭代，（因为根据描述，变异这个类型只会导致不正确的结果。</li>
</ul>
</li>
<li><p>缓冲区类型（BufferType）</p>
<ul>
<li>如果缓冲区方向是出（剩下的缓冲期方向还有入和出入两种 in&amp;inout）或者变量没长度？ 返回不变异，不会停止迭代。</li>
<li>如果是字符串型缓冲区并且值长度为1，则通常是常量，尤其是文件名。返回不变异，不会停止迭代。</li>
<li>如果是压缩的缓冲区（例如压缩的镜像），则应该优先变异，直接返回最高优先级，不会停止迭代。</li>
<li>否则返回 <code>0.8*maxPriority</code>，不会停止迭代。</li>
</ul>
</li>
<li><p>数组类型（ArrayType）</p>
<ul>
<li>如果开始范围等于结束范围并且它的种类是数组范围长度，则返回不变异，不会停止迭代。</li>
<li>否则返回最大优先级，不会停止迭代。</li>
</ul>
</li>
</ul>
<h2 id="变异规则按类型"><a href="#变异规则按类型" class="headerlink" title="变异规则按类型"></a>变异规则按类型</h2><h3 id="mutateInt"><a href="#mutateInt" class="headerlink" title="mutateInt"></a>mutateInt</h3><p>对需要变异的整数进行小范围的变化，增加或者减少 4 以内，或者随机翻转一位。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mutateInt</span><span class="params">(r *randGen, a *ConstArg, t *IntType)</span></span> <span class="type">uint64</span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> r.nOutOf(<span class="number">1</span>, <span class="number">3</span>): <span class="comment">// 1/3 的概率</span></span><br><span class="line">		<span class="keyword">return</span> a.Val + (<span class="type">uint64</span>(r.Intn(<span class="number">4</span>)) + <span class="number">1</span>) <span class="comment">// 对这个值随机增加 1～4</span></span><br><span class="line">	<span class="keyword">case</span> r.nOutOf(<span class="number">1</span>, <span class="number">2</span>): <span class="comment">// 1/3 的概率</span></span><br><span class="line">		<span class="keyword">return</span> a.Val - (<span class="type">uint64</span>(r.Intn(<span class="number">4</span>)) + <span class="number">1</span>) <span class="comment">// 对这个值随机减少 1～4</span></span><br><span class="line">	<span class="keyword">default</span>: <span class="comment">// 1/3 的概率 随机选择一位取反</span></span><br><span class="line">		<span class="keyword">return</span> a.Val ^ (<span class="number">1</span> &lt;&lt; <span class="type">uint64</span>(r.Intn(<span class="type">int</span>(t.TypeBitSize()))))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="mutateAlignedInt"><a href="#mutateAlignedInt" class="headerlink" title="mutateAlignedInt"></a>mutateAlignedInt</h3><p>对需要进行对齐的整型进行变异，主要就是在允许的范围内，变异这个数值对齐的位置。即想像成分页数据，则变异的是页码，而对应的页内位置不变。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mutateAlignedInt</span><span class="params">(r *randGen, a *ConstArg, t *IntType)</span></span> <span class="type">uint64</span> &#123;</span><br><span class="line">	<span class="comment">// 对需要对齐的 int 进行变异</span></span><br><span class="line">	rangeEnd := t.RangeEnd <span class="comment">// uint64</span></span><br><span class="line">	<span class="keyword">if</span> t.RangeBegin == <span class="number">0</span> &amp;&amp; <span class="type">int64</span>(rangeEnd) == <span class="number">-1</span> &#123;</span><br><span class="line">		<span class="comment">// Special [0:-1] range for all possible values.</span></span><br><span class="line">		rangeEnd = <span class="type">uint64</span>(<span class="number">1</span>&lt;&lt;t.TypeBitSize() - <span class="number">1</span>) <span class="comment">// 1000000...</span></span><br><span class="line">	&#125;</span><br><span class="line">	index := (a.Val - t.RangeBegin) / t.Align <span class="comment">// 以对齐的为单位 计算当前值所处偏移节</span></span><br><span class="line">	misalignment := (a.Val - t.RangeBegin) % t.Align <span class="comment">// 计算偏移节里面的偏移</span></span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> r.nOutOf(<span class="number">1</span>, <span class="number">3</span>): <span class="comment">// 1/3 的概率给偏移节增加 1~4</span></span><br><span class="line">		index += <span class="type">uint64</span>(r.Intn(<span class="number">4</span>)) + <span class="number">1</span></span><br><span class="line">	<span class="keyword">case</span> r.nOutOf(<span class="number">1</span>, <span class="number">2</span>): <span class="comment">// 1/3 的概率给偏移节减少 1~4</span></span><br><span class="line">		index -= <span class="type">uint64</span>(r.Intn(<span class="number">4</span>)) + <span class="number">1</span></span><br><span class="line">	<span class="keyword">default</span>: <span class="comment">// 1/3 的概率给偏移节 的随机一位取反</span></span><br><span class="line">		index ^= <span class="number">1</span> &lt;&lt; <span class="type">uint64</span>(r.Intn(<span class="type">int</span>(t.TypeBitSize())))</span><br><span class="line">	&#125;</span><br><span class="line">	lastIndex := (rangeEnd - t.RangeBegin) / t.Align <span class="comment">// 变化之后不能越界</span></span><br><span class="line">	index %= lastIndex + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> t.RangeBegin + index*t.Align + misalignment <span class="comment">// 起始加上对偏移节的变异加上节内偏移就是对齐的偏移</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="t-IntType-mutate"><a href="#t-IntType-mutate" class="headerlink" title="(t *IntType) mutate"></a>(t *IntType) mutate</h3><p>真正对整型数据进行变异。一半的概率直接重新生成，一半的概率根据是否需要对齐进行变异。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *IntType)</span></span> mutate(r *randGen, s *state, arg Arg, ctx ArgCtx) (calls []*Call, retry, preserve <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> r.bin() &#123; <span class="comment">// 1/2 的概率直接重新生成</span></span><br><span class="line">		<span class="keyword">return</span> regenerate(r, s, arg)</span><br><span class="line">	&#125;</span><br><span class="line">	a := arg.(*ConstArg) <span class="comment">// 剩下 1/2 的概率根据是否对齐进行变异</span></span><br><span class="line">	<span class="keyword">if</span> t.Align == <span class="number">0</span> &#123;</span><br><span class="line">		a.Val = mutateInt(r, a, t)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		a.Val = mutateAlignedInt(r, a, t)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 将变异后的数值转化为满足类型位数要求的数据（即mod</span></span><br><span class="line">	a.Val = truncateToBitSize(a.Val, t.TypeBitSize()) </span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="t-FlagsType-mutate"><a href="#t-FlagsType-mutate" class="headerlink" title="(t *FlagsType) mutate"></a>(t *FlagsType) mutate</h3><p>略微有点复杂，但是源代码中写了注释，还是简单解释了一下为啥是这样一些概率和设定。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *FlagsType)</span></span> mutate(r *randGen, s *state, arg Arg, ctx ArgCtx) (calls []*Call, retry, preserve <span class="type">bool</span>) &#123;</span><br><span class="line">	a := arg.(*ConstArg)</span><br><span class="line">	<span class="keyword">for</span> oldVal := a.Val; oldVal == a.Val; &#123;</span><br><span class="line">		a.Val = r.flags(t.Vals, t.BitMask, a.Val) <span class="comment">// 略微复杂 prog/rand.go</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="t-LenType-mutate"><a href="#t-LenType-mutate" class="headerlink" title="(t *LenType) mutate"></a>(t *LenType) mutate</h3><h3 id="t-ResourceType-VmaType-ProcType-mutate"><a href="#t-ResourceType-VmaType-ProcType-mutate" class="headerlink" title="(t ResourceType/\VmaType/*ProcType) mutate"></a>(t <em>ResourceType/\</em>VmaType/*ProcType) mutate</h3><p>直接重新生成</p>
<h3 id="t-BufferType-mutate"><a href="#t-BufferType-mutate" class="headerlink" title="(t *BufferType) mutate"></a>(t *BufferType) mutate</h3><h2 id="数据变异函数"><a href="#数据变异函数" class="headerlink" title="数据变异函数"></a>数据变异函数</h2><p>在 mutation.go 中的函数数组 <code>mutateDataFuncs</code> 定义了一系列数据变异的函数。这些变异函数统一在一个变异数组 <code>mutateDataFuncs</code> 中。</p>
<p>这个数组通过函数 <code>mutateData</code> 进行变异调度，以一个循环每次随机选择一个变异函数，然后当变异成功并且1/3的概率会停止迭代变异。</p>
<p>这个函数只在两个地方被调用了：</p>
<ul>
<li><code>(t *BufferType) mutate</code> 的类型为 <code>BufferBlobRand, BufferBlobRange</code> 和 <code>BufferString</code> 时；</li>
<li><code>squashAny</code> 中。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mutateData</span><span class="params">(r *randGen, data []<span class="type">byte</span>, minLen, maxLen <span class="type">uint64</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> stop := <span class="literal">false</span>; !stop; stop = stop &amp;&amp; r.oneOf(<span class="number">3</span>) &#123;</span><br><span class="line">		f := mutateDataFuncs[r.Intn(<span class="built_in">len</span>(mutateDataFuncs))] <span class="comment">// 随机选择一个变异函数</span></span><br><span class="line">		data, stop = f(r, data, minLen, maxLen)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体变异措施包括下面的函数，这些函数一般都会变异成功，毕竟只是对 bytes 进行操作，除非数据越界超过了预定义的最大或者最小范围:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Flip bit in byte. </span></span><br><span class="line"><span class="comment">// 从传入的bytes中随机选择一个字节的一位进行翻转</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Insert random bytes. </span></span><br><span class="line"><span class="comment">// 从传入bytes中随机选择一个位置插入随机不超过16个字节的随机数据，保证不超过最长长度，同时超过最大长度后或者有1/2的概率会在插入数据后，从末尾移除多余的字节保持原来的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Remove bytes. </span></span><br><span class="line"><span class="comment">// 从传入的bytes中随机移除中间随机不超过16个字节的数据。如果小于了最小长度或者有1/2的概率会在后面补齐0，保持原来的长度。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Append a bunch of bytes. </span></span><br><span class="line"><span class="comment">// 在不超过256的范围内倾向于选择一个更小的n，然后往传入的bytes后面一直填充0，保证不会超过最大长度。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Replace int8/int16/int32/int64 with a random value.</span></span><br><span class="line"><span class="comment">// 随机生成一个宽度 1 2 4 8 </span></span><br><span class="line"><span class="comment">// 然后将传入数据的后几个不超过上面宽度的字节以上面随机宽度的随机值来替换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Add/subtract from an int8/int16/int32/int64.</span></span><br><span class="line"><span class="comment">// 随机生成一个宽度 1 2 4 8 </span></span><br><span class="line"><span class="comment">// 然后将传入数据的后几个不超过上面宽度的字节加上一个 [-maxDelta, maxDelta] 的随机数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Set int8/int16/int32/int64 to an interesting value.</span></span><br><span class="line"><span class="comment">// 随机生成一个宽度 1 2 4 8 </span></span><br><span class="line"><span class="comment">// 然后将传入数据的后几个不超过上面宽度的字节 随机一个数uint64 然后以1/10的概率选择是否要将这个随机数以8bits为单位循环右移，然后将传入数据的后几位换成这个数</span></span><br></pre></td></tr></table></figure>
<h2 id="syz-fuzzer"><a href="#syz-fuzzer" class="headerlink" title="syz-fuzzer"></a>syz-fuzzer</h2><p>工作流程大概是这个样子</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/qriosa/picgo-blog/img/Syzkaller_work_flow.png" alt="Syzkaller_work_flow"></p>
<p>在 <code>syzkaller/syz-fuzzer</code> 文件夹下面是关于在被 <code>fuzz</code> 机器中执行组件的代码，这个部分是具体负责:</p>
<blockquote>
<p><code>syz-fuzzer</code> 进程则运行在大概率会不稳定的虚拟机上（被测试的内核上），该进程会对模糊测试进程的输入生成（generation）、变异（mutation）和最小化（minimization）等进行引导。同时会将触发了新的覆盖率的输入数据通过 RPC 返回给 <code>syz-manager</code> ，它还会临时启动并将需要运行的输入（program）发送给 <code>syz-executor</code> 进程执行。</p>
</blockquote>
<p>在这个代码中，一个 <code>proc</code> 实际是一个在虚拟机中跑的实例，负责自己的一系列 <code>fuzz</code> 事情。</p>
<blockquote>
<p>// Proc represents a single fuzzing process (executor).</p>
</blockquote>
<p><code>newProc</code> 就是生成一个新的 <code>fuzz</code> 进程，其中会配置一些相关的参数和变量，然后返回一个 <code>proc</code> 实例。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newProc</span><span class="params">(fuzzer *Fuzzer, pid <span class="type">int</span>)</span></span> (*Proc, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p><code>loop</code> 就是一个 <code>fuzz</code> 实例的具体主循环部分了，这是一个死循环，一直进行持续的 <code>fuzz</code> 直到有退出信号。正常情况下，生成和变异的比例大约是 <code>1:99</code> 。<code>prog.RecommendedCalls</code> 是用于指示生成和变异的 <code>prog</code> 中的 <code>ncall</code> 即指示系统调用数量。定义在 <a href="/syzkaller/syz-fuzzer/proc.go">syz-fuzzer/proc.go:line 62</a> 。</p>
<p>对该部分代码进行再次仔细的分析，会发现当 fuzzer 的工作队列不为空时将不会执行下面的生成和变异，即并不会去通过fuzzer快照生成一个新的fuzzer，整个循环到这里就结束了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proc.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proc *Proc)</span></span> loop() &#123;</span><br><span class="line">	generatePeriod := <span class="number">100</span> <span class="comment">// 生成周期，当达到这个周期时，就调用生成一个，否则就变异一个。</span></span><br><span class="line">	<span class="keyword">if</span> proc.fuzzer.config.Flags&amp;ipc.FlagSignal == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// If we don&#x27;t have real coverage signal, generate programs more frequently</span></span><br><span class="line">		<span class="comment">// because fallback signal is weak.</span></span><br><span class="line">		generatePeriod = <span class="number">2</span>  <span class="comment">// 如果反馈信号很弱，就缩短生成周期，也就是提高生成的比例</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123; <span class="comment">// 任何地方开始进行执行并处理时 都会经过一个判断 然后往当前fuzzer的工作队列中添加对应的工作状态</span></span><br><span class="line">		item := proc.fuzzer.workQueue.dequeue()</span><br><span class="line">		<span class="keyword">if</span> item != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">switch</span> item := item.(<span class="keyword">type</span>) &#123; <span class="comment">// 判断当前 fuzzer 的工作状态</span></span><br><span class="line">			<span class="keyword">case</span> *WorkTriage:</span><br><span class="line">				proc.triageInput(item) <span class="comment">// 具体对执行情况进行鉴别</span></span><br><span class="line">			<span class="keyword">case</span> *WorkCandidate: <span class="comment">// 就是直接执行 prog</span></span><br><span class="line">				proc.execute(proc.execOpts, item.p, item.flags, StatCandidate)</span><br><span class="line">			<span class="keyword">case</span> *WorkSmash: <span class="comment">// 在粉碎输入，由triageInput 发现添加了新输入后并结合配置文件来添加此阶段， 该阶段会强制对这个输入进行100次变异得到100个新输入，执行100次？</span></span><br><span class="line">				proc.smashInput(item)</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				log.Fatalf(<span class="string">&quot;unknown work type: %#v&quot;</span>, item)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 只有当前fuzzer的工作队列为空的时候才会进行新 synthesis 一个 prog 然后执行并收集</span></span><br><span class="line">		ct := proc.fuzzer.choiceTable  <span class="comment">// 获取当前 fuzzer 的选择表</span></span><br><span class="line">		fuzzerSnapshot := proc.fuzzer.snapshot()  <span class="comment">// 保存当前 fuzzer 获取的快照</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(fuzzerSnapshot.corpus) == <span class="number">0</span> || i%generatePeriod == <span class="number">0</span> &#123; <span class="comment">// 种子库为空 或者 生成周期到了 </span></span><br><span class="line">			<span class="comment">// Generate a new prog.</span></span><br><span class="line">			p := proc.fuzzer.target.Generate(proc.rnd, prog.RecommendedCalls, ct) <span class="comment">// 直接生成一个新输入</span></span><br><span class="line">			log.Logf(<span class="number">1</span>, <span class="string">&quot;#%v: generated&quot;</span>, proc.pid)</span><br><span class="line">			proc.executeAndCollide(proc.execOpts, p, ProgNormal, StatGenerate)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则是选择进行变异而不是生成</span></span><br><span class="line">			<span class="comment">// Mutate an existing prog.</span></span><br><span class="line">			p := fuzzerSnapshot.chooseProgram(proc.rnd).Clone()  <span class="comment">// 从当前快走的种子库中选择一个种子 </span></span><br><span class="line">			p.Mutate(proc.rnd, prog.RecommendedCalls, ct, proc.fuzzer.noMutate, fuzzerSnapshot.corpus)  <span class="comment">// 调用上面的变异函数进行变异 得到一个变异的输入 p</span></span><br><span class="line">			log.Logf(<span class="number">1</span>, <span class="string">&quot;#%v: mutated&quot;</span>, proc.pid)</span><br><span class="line">			proc.executeAndCollide(proc.execOpts, p, ProgNormal, StatFuzz)  <span class="comment">// 简单跑一下看</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>fuzzerSnapshot.chooseProgram</code> 定义在 <a href="/syzkaller/syz-fuzzer/fuzzer.go">syz-fuzzer/fuzzer.go:line 517</a> 。会根据当前 <code>fuzzer</code> 中的一个参数值 <code>sumPrios</code> （猜测这个参数与当前的种子数有关），获取一个小于这个参数的随机数 <code>randVal</code>，然后顺序查找种子库中的第一个优先级大于等于 <code>randVal</code> 种子进行返回。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fuzzer *FuzzerSnapshot)</span></span> chooseProgram(r *rand.Rand) *prog.Prog &#123;</span><br><span class="line">	randVal := r.Int63n(fuzzer.sumPrios + <span class="number">1</span>)</span><br><span class="line">	idx := sort.Search(<span class="built_in">len</span>(fuzzer.corpusPrios), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fuzzer.corpusPrios[i] &gt;= randVal</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> fuzzer.corpus[idx]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>proc.fuzzer.target.Generate</code> 定义在 <a href="/syzkaller/prog/generation.go">prog/generation.go:line 12</a> 。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generate generates a random program with ncalls calls.</span></span><br><span class="line"><span class="comment">// ct contains a set of allowed syscalls, if nil all syscalls are used.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(target *Target)</span></span> Generate(rs rand.Source, ncalls <span class="type">int</span>, ct *ChoiceTable) *Prog &#123;</span><br><span class="line">	p := &amp;Prog&#123;</span><br><span class="line">		Target: target,</span><br><span class="line">	&#125;</span><br><span class="line">	r := newRand(target, rs)</span><br><span class="line">	s := newState(target, ct, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(p.Calls) &lt; ncalls &#123;</span><br><span class="line">    calls := r.generateCall(s, p, <span class="built_in">len</span>(p.Calls)) <span class="comment">// (state, prog, insertionPoint)</span></span><br><span class="line">		<span class="keyword">for</span> _, c := <span class="keyword">range</span> calls &#123;</span><br><span class="line">			s.analyze(c)</span><br><span class="line">			p.Calls = <span class="built_in">append</span>(p.Calls, c)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// For the last generated call we could get additional calls that create</span></span><br><span class="line">	<span class="comment">// resources and overflow ncalls. Remove some of these calls.</span></span><br><span class="line">	<span class="comment">// The resources in the last call will be replaced with the default values,</span></span><br><span class="line">	<span class="comment">// which is exactly what we want.</span></span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(p.Calls) &gt; ncalls &#123;</span><br><span class="line">		p.RemoveCall(ncalls - <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	p.sanitizeFix()</span><br><span class="line">	p.debugValidate()</span><br><span class="line">	<span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 而对于其中的 <code>r.generateCall</code> 定义在 <a href="/syzkaller/prog/rand.go">prog/rand.go:line 561</a> 。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *randGen)</span></span> generateCall(s *state, p *Prog, insertionPoint <span class="type">int</span>) []*Call &#123;</span><br><span class="line">	biasCall := <span class="number">-1</span></span><br><span class="line">	<span class="keyword">if</span> insertionPoint &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Choosing the base call is based on the insertion point of the new calls sequence.</span></span><br><span class="line">		insertionCall := p.Calls[r.Intn(insertionPoint)].Meta</span><br><span class="line">		<span class="keyword">if</span> !insertionCall.Attrs.NoGenerate &#123;</span><br><span class="line">			<span class="comment">// We must be careful not to bias towards a non-generatable call.</span></span><br><span class="line">			biasCall = insertionCall.ID</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	idx := s.ct.choose(r.Rand, biasCall)</span><br><span class="line">	meta := r.target.Syscalls[idx]</span><br><span class="line">	<span class="keyword">return</span> r.generateParticularCall(s, meta)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>executeAndCollide</code> 定义在 <a href="/syzkaller/syz-fuzzer/proc.go">syz-fuzzer/proc.go:line 283</a> 。到这里我就没有继续跟了，有空再来跟。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proc *Proc)</span></span> executeAndCollide(execOpts *ipc.ExecOpts, p *prog.Prog, flags ProgTypes, stat Stat) &#123;</span><br><span class="line">	proc.execute(execOpts, p, flags, stat)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> proc.execOptsCollide.Flags&amp;ipc.FlagThreaded == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// We cannot collide syscalls without being in the threaded mode.</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">const</span> collideIterations = <span class="number">2</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; collideIterations; i++ &#123;</span><br><span class="line">		proc.executeRaw(proc.execOptsCollide, proc.randomCollide(p), StatCollide)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 <code>proc.executeRaw()</code> 后，反正是进入了 <code>ipc.Env.Exec</code> 来进行执行的。</p>
<h2 id="ipc"><a href="#ipc" class="headerlink" title="ipc"></a>ipc</h2><p>该部分组件定义在 <a href="/syzkaller/pkg/ipc">ipc/</a> ，其中 <code>ipc.Env.Exec</code> 定义在 <a href="/syzkaller/pkg/ipc/sipc.go">ip c.go:line 255</a> 。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Exec starts executor binary to execute program p and returns information about the execution:</span></span><br><span class="line"><span class="comment">// output: process output</span></span><br><span class="line"><span class="comment">// info: per-call info</span></span><br><span class="line"><span class="comment">// hanged: program hanged and was killed</span></span><br><span class="line"><span class="comment">// err0: failed to start the process or bug in executor itself.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(env *Env)</span></span> Exec(opts *ExecOpts, p *prog.Prog) (output []<span class="type">byte</span>, info *ProgInfo, hanged <span class="type">bool</span>, err0 <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// Copy-in serialized program.</span></span><br><span class="line">	progSize, err := p.SerializeForExec(env.in)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		err0 = err</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> progData []<span class="type">byte</span></span><br><span class="line">	<span class="keyword">if</span> !env.config.UseShmem &#123;</span><br><span class="line">		progData = env.in[:progSize]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Zero out the first two words (ncmd and nsig), so that we don&#x27;t have garbage there</span></span><br><span class="line">	<span class="comment">// if executor crashes before writing non-garbage there.</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">		env.out[i] = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	atomic.AddUint64(&amp;env.StatExecs, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">if</span> env.cmd == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> p.Target.OS != targets.TestOS &amp;&amp; targets.Get(p.Target.OS, p.Target.Arch).HostFuzzer &#123;</span><br><span class="line">			<span class="comment">// The executor is actually ssh,</span></span><br><span class="line">			<span class="comment">// starting them too frequently leads to timeouts.</span></span><br><span class="line">			&lt;-rateLimit.C</span><br><span class="line">		&#125;</span><br><span class="line">		tmpDirPath := <span class="string">&quot;./&quot;</span></span><br><span class="line">		atomic.AddUint64(&amp;env.StatRestarts, <span class="number">1</span>)</span><br><span class="line">		env.cmd, err0 = makeCommand(env.pid, env.bin, env.config, env.inFile, env.outFile, env.out, tmpDirPath)</span><br><span class="line">		<span class="keyword">if</span> err0 != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	output, hanged, err0 = env.cmd.exec(opts, progData)</span><br><span class="line">	<span class="keyword">if</span> err0 != <span class="literal">nil</span> &#123;</span><br><span class="line">		env.cmd.<span class="built_in">close</span>()</span><br><span class="line">		env.cmd = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	info, err0 = env.parseOutput(p, opts)</span><br><span class="line">	<span class="keyword">if</span> info != <span class="literal">nil</span> &amp;&amp; env.config.Flags&amp;FlagSignal == <span class="number">0</span> &#123;</span><br><span class="line">		addFallbackSignal(p, info)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !env.config.UseForkServer &#123;</span><br><span class="line">		env.cmd.<span class="built_in">close</span>()</span><br><span class="line">		env.cmd = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="覆盖收集"><a href="#覆盖收集" class="headerlink" title="覆盖收集"></a>覆盖收集</h2><p><code>triageInput</code> 定义在 <a href="/syzkaller/syz-fuzzer/proc.go">syz-fuzzer/proc.go:line 102</a> ，在这里测算覆盖率，进行重执行，进行最小化操作，将输入添加到种子库中，发送该种子信息给 <code>syz-manager</code> 。</p>
<p>实际测算覆盖率时，其实是每个输入覆盖的PC的数量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proc *Proc)</span></span> triageInput(item *WorkTriage) &#123;</span><br><span class="line">	log.Logf(<span class="number">1</span>, <span class="string">&quot;#%v: triaging type=%x&quot;</span>, proc.pid, item.flags)</span><br><span class="line"></span><br><span class="line">	prio := signalPrio(item.p, &amp;item.info, item.call)</span><br><span class="line">	inputSignal := signal.FromRaw(item.info.Signal, prio)</span><br><span class="line">	newSignal := proc.fuzzer.corpusSignalDiff(inputSignal)</span><br><span class="line">	<span class="keyword">if</span> newSignal.Empty() &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	callName := <span class="string">&quot;.extra&quot;</span></span><br><span class="line">	logCallName := <span class="string">&quot;extra&quot;</span></span><br><span class="line">	<span class="keyword">if</span> item.call != <span class="number">-1</span> &#123;</span><br><span class="line">		callName = item.p.Calls[item.call].Meta.Name</span><br><span class="line">		logCallName = fmt.Sprintf(<span class="string">&quot;call #%v %v&quot;</span>, item.call, callName)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Logf(<span class="number">3</span>, <span class="string">&quot;triaging input for %v (new signal=%v)&quot;</span>, logCallName, newSignal.Len())</span><br><span class="line">	<span class="keyword">var</span> inputCover cover.Cover</span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		signalRuns       = <span class="number">3</span></span><br><span class="line">		minimizeAttempts = <span class="number">3</span></span><br><span class="line">	)</span><br><span class="line">	<span class="comment">// Compute input coverage and non-flaky signal for minimization.</span></span><br><span class="line">	notexecuted := <span class="number">0</span></span><br><span class="line">	rawCover := []<span class="type">uint32</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; signalRuns; i++ &#123;</span><br><span class="line">		info := proc.executeRaw(proc.execOptsCover, item.p, StatTriage)</span><br><span class="line">		<span class="keyword">if</span> !reexecutionSuccess(info, &amp;item.info, item.call) &#123;</span><br><span class="line">			<span class="comment">// The call was not executed or failed.</span></span><br><span class="line">			notexecuted++</span><br><span class="line">			<span class="keyword">if</span> notexecuted &gt; signalRuns/<span class="number">2</span>+<span class="number">1</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="comment">// if happens too often, give up</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		thisSignal, thisCover := getSignalAndCover(item.p, info, item.call)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(rawCover) == <span class="number">0</span> &amp;&amp; proc.fuzzer.fetchRawCover &#123;</span><br><span class="line">			rawCover = <span class="built_in">append</span>([]<span class="type">uint32</span>&#123;&#125;, thisCover...)</span><br><span class="line">		&#125;</span><br><span class="line">		newSignal = newSignal.Intersection(thisSignal)</span><br><span class="line">		<span class="comment">// Without !minimized check manager starts losing some considerable amount</span></span><br><span class="line">		<span class="comment">// of coverage after each restart. Mechanics of this are not completely clear.</span></span><br><span class="line">		<span class="keyword">if</span> newSignal.Empty() &amp;&amp; item.flags&amp;ProgMinimized == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		inputCover.Merge(thisCover)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> item.flags&amp;ProgMinimized == <span class="number">0</span> &#123;</span><br><span class="line">		item.p, item.call = prog.Minimize(item.p, item.call, <span class="literal">false</span>,</span><br><span class="line">			<span class="function"><span class="keyword">func</span><span class="params">(p1 *prog.Prog, call1 <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">				<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; minimizeAttempts; i++ &#123;</span><br><span class="line">					info := proc.execute(proc.execOpts, p1, ProgNormal, StatMinimize)</span><br><span class="line">					<span class="keyword">if</span> !reexecutionSuccess(info, &amp;item.info, call1) &#123;</span><br><span class="line">						<span class="comment">// The call was not executed or failed.</span></span><br><span class="line">						<span class="keyword">continue</span></span><br><span class="line">					&#125;</span><br><span class="line">					thisSignal, _ := getSignalAndCover(p1, info, call1)</span><br><span class="line">					<span class="keyword">if</span> newSignal.Intersection(thisSignal).Len() == newSignal.Len() &#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">			&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里将输入进行序列化 并计算了序列化之后到 hash</span></span><br><span class="line">	data := item.p.Serialize()</span><br><span class="line">	sig := hash.Hash(data)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印添加到库中的日志 并发送到 manager</span></span><br><span class="line">	log.Logf(<span class="number">2</span>, <span class="string">&quot;added new input for %v to corpus:\n%s&quot;</span>, logCallName, data)</span><br><span class="line">	proc.fuzzer.sendInputToManager(rpctype.Input&#123;</span><br><span class="line">		Call:     callName,</span><br><span class="line">		CallID:   item.call,</span><br><span class="line">		Prog:     data,</span><br><span class="line">		Signal:   inputSignal.Serialize(),</span><br><span class="line">		Cover:    inputCover.Serialize(),</span><br><span class="line">		RawCover: rawCover,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过该 fuzzer 添加到种子库中</span></span><br><span class="line">	proc.fuzzer.addInputToCorpus(item.p, inputSignal, sig)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里应该是判断当前还是否应该继续回到工作队列中继续工作</span></span><br><span class="line">	<span class="keyword">if</span> item.flags&amp;ProgSmashed == <span class="number">0</span> &#123;</span><br><span class="line">		proc.fuzzer.workQueue.enqueue(&amp;WorkSmash&#123;item.p, item.call&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x04-cov-web-的查看"><a href="#0x04-cov-web-的查看" class="headerlink" title="0x04 cov web 的查看"></a>0x04 cov web 的查看</h1><p>Syzkaller 专门提供了web页面的覆盖率查看功能。具体实现大致在 <code>/syzkaller/pkg/cover</code> 中。web 页面的实现主要看文件  <code>/syzkaller/pkg/cover/html.go</code> 。</p>
<h2 id="DoHTML"><a href="#DoHTML" class="headerlink" title="DoHTML"></a>DoHTML</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /syzkaller/pkg/cover/html.go line:27</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rg *ReportGenerator)</span></span> DoHTML(w io.Writer, progs []Prog, coverFilter <span class="keyword">map</span>[<span class="type">uint32</span>]<span class="type">uint32</span>) <span class="type">error</span> &#123;</span><br><span class="line">	progs = fixUpPCs(rg.target.Arch, progs, coverFilter)</span><br><span class="line">	files, err := rg.prepareFileMap(progs)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	d := &amp;templateData&#123;</span><br><span class="line">		Root:     <span class="built_in">new</span>(templateDir),</span><br><span class="line">		RawCover: rg.rawCoverEnabled,</span><br><span class="line">	&#125;</span><br><span class="line">	haveProgs := <span class="built_in">len</span>(progs) &gt; <span class="number">1</span> || progs[<span class="number">0</span>].Data != <span class="string">&quot;&quot;</span></span><br><span class="line">	fileOpenErr := fmt.Errorf(<span class="string">&quot;failed to open/locate any source file&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> fname, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">		pos := d.Root</span><br><span class="line">		path := <span class="string">&quot;&quot;</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> path != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">				path += <span class="string">&quot;/&quot;</span></span><br><span class="line">			&#125;</span><br><span class="line">			sep := strings.IndexByte(fname, filepath.Separator)</span><br><span class="line">			<span class="keyword">if</span> sep == <span class="number">-1</span> &#123;</span><br><span class="line">				path += fname</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			dir := fname[:sep]</span><br><span class="line">			path += dir</span><br><span class="line">			<span class="keyword">if</span> pos.Dirs == <span class="literal">nil</span> &#123;</span><br><span class="line">				pos.Dirs = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*templateDir)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> pos.Dirs[dir] == <span class="literal">nil</span> &#123;</span><br><span class="line">				pos.Dirs[dir] = &amp;templateDir&#123;</span><br><span class="line">					templateBase: templateBase&#123;</span><br><span class="line">						Path: path,</span><br><span class="line">						Name: dir,</span><br><span class="line">					&#125;,</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			pos = pos.Dirs[dir]</span><br><span class="line">			fname = fname[sep+<span class="number">1</span>:]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> TotalInCoveredFunc <span class="type">int</span></span><br><span class="line">		<span class="keyword">for</span> _, function := <span class="keyword">range</span> file.functions &#123;</span><br><span class="line">			<span class="keyword">if</span> function.covered &gt; <span class="number">0</span> &#123;</span><br><span class="line">				TotalInCoveredFunc += function.pcs</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		f := &amp;templateFile&#123;</span><br><span class="line">			templateBase: templateBase&#123;</span><br><span class="line">				Path:               path, <span class="comment">// 路径</span></span><br><span class="line">				Name:               fname, <span class="comment">// 文件名</span></span><br><span class="line">				Total:              file.totalPCs, <span class="comment">// 文件的总PC数</span></span><br><span class="line">				TotalInCoveredFunc: TotalInCoveredFunc, <span class="comment">// 文件中有覆盖的函数的总PC数的和</span></span><br><span class="line">				Covered:            file.coveredPCs, <span class="comment">// 文件中有多少覆盖了的 PC</span></span><br><span class="line">			&#125;,</span><br><span class="line">			HasFunctions: <span class="built_in">len</span>(file.functions) != <span class="number">0</span>, <span class="comment">// 该文件是否含有函数</span></span><br><span class="line">		&#125;</span><br><span class="line">		pos.Files = <span class="built_in">append</span>(pos.Files, f)</span><br><span class="line">		<span class="keyword">if</span> file.coveredPCs == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		addFunctionCoverage(file, d)</span><br><span class="line">		contents := <span class="string">&quot;&quot;</span></span><br><span class="line">		lines, err := parseFile(file.filename)</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			contents = fileContents(file, lines, haveProgs)</span><br><span class="line">			fileOpenErr = <span class="literal">nil</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// We ignore individual errors of opening/locating source files</span></span><br><span class="line">			<span class="comment">// because there is a number of reasons when/why it can happen.</span></span><br><span class="line">			<span class="comment">// We fail only if we can&#x27;t open/locate any single source file.</span></span><br><span class="line">			<span class="comment">// syz-ci can mess state of source files (https://github.com/google/syzkaller/issues/1770),</span></span><br><span class="line">			<span class="comment">// or bazel lies about location of auto-generated files,</span></span><br><span class="line">			<span class="comment">// or a used can update source files with git pull/checkout.</span></span><br><span class="line">			contents = html.EscapeString(err.Error())</span><br><span class="line">			<span class="keyword">if</span> fileOpenErr != <span class="literal">nil</span> &#123;</span><br><span class="line">				fileOpenErr = err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		d.Contents = <span class="built_in">append</span>(d.Contents, template.HTML(contents))</span><br><span class="line">		f.Index = <span class="built_in">len</span>(d.Contents) - <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> fileOpenErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fileOpenErr</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, prog := <span class="keyword">range</span> progs &#123;</span><br><span class="line">		d.Progs = <span class="built_in">append</span>(d.Progs, templateProg&#123;</span><br><span class="line">			Sig:     prog.Sig,</span><br><span class="line">			Content: template.HTML(html.EscapeString(prog.Data)),</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	processDir(d.Root) <span class="comment">// 进一步对文件夹进行递归处理 转下</span></span><br><span class="line">	<span class="keyword">return</span> coverTemplate.Execute(w, d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="processDir"><a href="#processDir" class="headerlink" title="processDir"></a>processDir</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /syzkaller/pkg/cover/html.go line:740</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processDir</span><span class="params">(dir *templateDir)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(dir.Dirs) == <span class="number">1</span> &amp;&amp; <span class="built_in">len</span>(dir.Files) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, child := <span class="keyword">range</span> dir.Dirs &#123;</span><br><span class="line">			dir.Name += <span class="string">&quot;/&quot;</span> + child.Name</span><br><span class="line">			dir.Files = child.Files</span><br><span class="line">			dir.Dirs = child.Dirs</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Slice(dir.Files, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> dir.Files[i].Name &lt; dir.Files[j].Name</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> dir.Files &#123;</span><br><span class="line">		dir.Total += f.Total <span class="comment">// 文件夹PC总数为其中的文件的PC总数的和</span></span><br><span class="line">		dir.Covered += f.Covered <span class="comment">// 文件夹覆盖的PC总数为其中文件的覆盖总数的和</span></span><br><span class="line">		dir.TotalInCoveredFunc += f.TotalInCoveredFunc <span class="comment">// 文件夹的有触发的函数的PC总数为其中所有的文件中的所有的有触发的函数的PC总数的和。</span></span><br><span class="line">		f.Percent = percent(f.Covered, f.Total) <span class="comment">// 文件覆盖率=文件覆盖数/文件总PC数</span></span><br><span class="line">		<span class="keyword">if</span> f.TotalInCoveredFunc &gt; <span class="number">0</span> &#123;</span><br><span class="line">			f.PercentInCoveredFunc = percent(f.Covered, f.TotalInCoveredFunc)</span><br><span class="line">            <span class="comment">// 文件函数触发覆盖率=文件覆盖数/文件中的所有的有触发的函数的PC总数的和</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, child := <span class="keyword">range</span> dir.Dirs &#123;</span><br><span class="line">		processDir(child) <span class="comment">// 递归的方式处理其中所有子文件夹</span></span><br><span class="line">        dir.Total += child.Total <span class="comment">// 文件夹PC总数为其子文件(夹)PC总数之和</span></span><br><span class="line">		dir.Covered += child.Covered <span class="comment">// 文件夹覆盖PC总数为其子文件(夹)覆盖PC总数之和</span></span><br><span class="line">		dir.TotalInCoveredFunc += child.TotalInCoveredFunc </span><br><span class="line">        <span class="comment">// 文件夹的有触发函数的PC总数为为其子文件(夹)的有触发函数的PC总数的和</span></span><br><span class="line">	&#125;</span><br><span class="line">	dir.Percent = percent(dir.Covered, dir.Total)</span><br><span class="line">	<span class="keyword">if</span> dir.TotalInCoveredFunc &gt; <span class="number">0</span> &#123;</span><br><span class="line">		dir.PercentInCoveredFunc += percent(dir.Covered, dir.TotalInCoveredFunc)</span><br><span class="line">        <span class="comment">// 文件夹函数触发覆盖率=文件夹覆盖数/文件夹中的有触发的函数的PC总数的和</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> dir.Covered == <span class="number">0</span> &#123;</span><br><span class="line">		dir.Dirs = <span class="literal">nil</span></span><br><span class="line">		dir.Files = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><h3 id="覆盖率分析"><a href="#覆盖率分析" class="headerlink" title="覆盖率分析"></a>覆盖率分析</h3><p>Syzkaller 提供了web接口进行查看，同时也提供了命令行工具进行查看。(docs/coverage.md)</p>
<p>这里对web-interface进行解释。</p>
<p>首先是左侧边栏中的数据。</p>
<ul>
<li>左侧表示内核中的文件夹和文件。</li>
<li>中间有两个百分数表示当前对这个文件/文件夹的覆盖率。<ul>
<li>括号外面的是：当前覆盖到的PC数量除以整个文件或者文件夹中的所有的PC数得到的百分比，也就是绝对覆盖率。</li>
<li>括号里面是：当前覆盖到的PC数量除以当前文件或者文件夹中所有有被覆盖到的函数的总PC数量得到的百分比。反映的就是到达的函数中，这些函数有多大的比例已经被完全覆盖了。</li>
</ul>
</li>
<li>右侧两个数表示当前文件/文件夹的PC总数量。<ul>
<li>括号外面是这个文件/文件夹中的所有的PC的总数量。</li>
<li>括号里面是，当前有到达过的函数的PC的总数量。所以随着fuzz过程继续，这个值应该会持续变大。</li>
</ul>
</li>
</ul>
<p>然后是右侧内容框中的数据。</p>
<ul>
<li>左侧表示函数的名字。</li>
<li>中间表示这个函数覆盖的PC数除以该函数的PC总数，即该函数的覆盖率。</li>
<li>右侧这个数字表示这个函数所拥有的PC总数。</li>
<li>最下面的 <code>SUMMARY</code> 则是表示一个平均，即当前这个文件中所有的到达的PC数除以当前文件中有被覆盖到的函数的PC总数的和得到的覆盖率。（即上一个括号中的比例。</li>
<li>最下面右侧统计的则是，当前文件中所有的有到达的函数拥有的PC总数。</li>
</ul>
<h3 id="源码分析与查看"><a href="#源码分析与查看" class="headerlink" title="源码分析与查看"></a>源码分析与查看</h3><p>而当点击文件名时，会出来这个文件对应的源码。<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/coverage.md#web-interface">web-interface</a> 有解释。</p>
<p>全黑的行表示这一行对应的所有的PC值都被完全覆盖了。左侧会有一个数字，表明有多少个prog已触发执行与该行关联的 PC 值。点击该数字会展示最后一个执行的prog是啥。</p>
<p>橙色则是表示这一行相关的PC值没有完全被执行覆盖。左侧的数字含义相同。</p>
<p>赤红色表示 weak-uncovered，意思是这一行所示的函数或者符合根本不可能到达。但可能会因为变异优化符号表缺失或者函数修改内嵌等方式有误。</p>
<p>红色表示理论上可以到但是没有被覆盖到的单行？</p>
<blockquote>
<p>Line is uncovered. Function (symbol) this line is in is executed and one of the PC values associated to this line. Example below shows how single line which is not covered is shown.</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://github.com/google/syzkaller/raw/master/docs/coverage_uncovered.png?raw=true" alt="红色行"></p>
<p>灰色表示没有被插桩的。PC关联过去的行根本没有被插桩或者该源码行根本没有生成任何code。</p>
<h1 id="0x05-执行-prog"><a href="#0x05-执行-prog" class="headerlink" title="0x05 执行 prog"></a>0x05 执行 prog</h1><p>在Syzkaller报告了某个 <code>bug</code> 之后，可以自己再执行该输入。</p>
<p>教程文档在（docs/executing_syzkaller_programs.md）</p>
<p>关于执行和判别触发 <code>crash</code> 的输入文件 （docs/eproducing_crashes.md）将很有用。</p>
<p>基本思路是，用qemu将目标内核拖起来，然后将必要的文件发送到目标系统中，然后执行。</p>
<ul>
<li><p>首先将目标系统拖起来，这里和编译Syzkaller时一样，直接qemu拖起来即可。</p>
</li>
<li><p>然后使用命令将必要的文件发送进去。<br><code>-P 10021</code> 是拖起来的待测试系统的端口<br><code>-i</code> 指定的是和目标系统 <code>ssh</code> 通信的认证文件，一般是 <code>bullseye.id_rsa</code><br><code>syz-execprog</code> 就是读取 prog 文件，然后调用 executor 进行执行的程序。<br><code>syz-executor</code> 就是在目标系统中解析我们给定的prog并进行执行的可执行文件<br><code>program</code> 就是给出的想执行的 prog，疑似就是 <code>repro.prog</code> 中的数据即可。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -P 10021 -i bullseye.img.key bin/linux_amd64/syz-execprog bin/linux_amd64/syz-executor program root@localhost:</span><br></pre></td></tr></table></figure>
<p>执行命令可能会报错：<code>Offending ECDSA key in /home/th1nk5t4ti0n/.ssh/known_hosts:18</code> 根据错误下面的提示，会让执行一个删除命令，根据这个删除命令，把文件中冲突的已知主机的key删除即可。</p>
</li>
<li><p>然后在目标系统中执行下面的命令即可。<br>其中一些参数可以根据  <code>repro.prog</code> 中的值进行设定。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./syz-execprog -repeat=0 -procs=8 program</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>eproducing_crashes.md 还讲述了怎么从多个里面找到某个、尝试最小化和使用prog2c工具。</p>
<h1 id="0x06-Crash"><a href="#0x06-Crash" class="headerlink" title="0x06 Crash"></a>0x06 Crash</h1><p><a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/usage.md#crashes">link</a> .</p>
<blockquote>
<p>Once syzkaller detected a kernel crash in one of the VMs, it will automatically start the process of reproducing this crash (unless you specified <code>&quot;reproduce&quot;: false</code> in the config). By default it will use 4 VMs to reproduce the crash and then minimize the program that caused it. This may stop the fuzzing, since all of the VMs might be busy reproducing detected crashes.</p>
</blockquote>
<h1 id="0x07-实际编译测试"><a href="#0x07-实际编译测试" class="headerlink" title="0x07 实际编译测试"></a>0x07 实际编译测试</h1><h2 id="Linux-6-22"><a href="#Linux-6-22" class="headerlink" title="Linux-6.22"></a>Linux-6.22</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> make defconfig</span><br><span class="line"><span class="built_in">sudo</span> make kvm_guest.config</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> ./scripts/config \</span><br><span class="line">-e PCI \</span><br><span class="line">-e VIRTIO_PCI \</span><br><span class="line">-e KCOV \</span><br><span class="line">-e DEBUG_INFO \</span><br><span class="line">-e KASAN \</span><br><span class="line">-e KASAN_INLINE \</span><br><span class="line">-e CONFIGFS_FS \</span><br><span class="line">-e DEBUG_INFO_DWARF4 \</span><br><span class="line">-e CONFIGFS_FS \</span><br><span class="line">-e SECURITYFS \</span><br><span class="line">-e CONFIG_PCI \</span><br><span class="line">-e CONFIG_VIRTIO_PCI \</span><br><span class="line">-e CONFIG_DEBUG_INFO \</span><br><span class="line">-e CONFIG_KASAN \</span><br><span class="line">-e CONFIG_KASAN_INLINE \</span><br><span class="line">-e CONFIG_CONFIGFS_FS \</span><br><span class="line">-e CONFIG_KCOV \</span><br><span class="line">-e CONFIG_DEBUG_INFO_DWARF4</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> make olddefconfig</span><br><span class="line"><span class="built_in">sudo</span> make -j`<span class="built_in">nproc</span>`</span><br></pre></td></tr></table></figure>
<h1 id="0x08-一些过程命令脚本"><a href="#0x08-一些过程命令脚本" class="headerlink" title="0x08 一些过程命令脚本"></a>0x08 一些过程命令脚本</h1><p><code>syz_install.sh</code> 我在实验过程中的一些实用性脚本</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># go</span></span><br><span class="line">wget https://dl.google.com/go/go1.20.1.linux-amd64.tar.gz</span><br><span class="line">tar -xf go1.20.1.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> GOROOT=`<span class="built_in">pwd</span>`/go</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$GOROOT</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install make gcc flex bison libncurses-dev libelf-dev libssl-dev git g++</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># kernel</span></span><br><span class="line">git <span class="built_in">clone</span> --branch v6.2 git://mirrors.ustc.edu.cn/linux.git <span class="variable">$KERNEL</span></span><br><span class="line"><span class="built_in">cd</span> linux</span><br><span class="line"><span class="built_in">export</span> KERNEL=`<span class="built_in">pwd</span>`</span><br><span class="line"></span><br><span class="line"><span class="comment"># if you want to use clang, add `CC=clang` after make.</span></span><br><span class="line">make defconfig 			<span class="comment"># make CC=clang defconfig</span></span><br><span class="line">make kvm_guest.config 	<span class="comment"># make CC=clang kvm_guest.config</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> ./scripts/config \</span><br><span class="line">-e KCOV \</span><br><span class="line">-e KCOV_ENABLE_COMPARISONS \</span><br><span class="line">-e DEBUG_INFO_DWARF4 \</span><br><span class="line">-e KASAN \</span><br><span class="line">-e KASAN_INLINE \</span><br><span class="line">-e CONFIGFS_FS \</span><br><span class="line">-e SECURITYFS \</span><br><span class="line">-e CONFIG_KCOV \</span><br><span class="line">-e CONFIG_DEBUG_INFO_DWARF4 \</span><br><span class="line">-e CONFIG_KASAN \</span><br><span class="line">-e CONFIG_KASAN_INLINE \</span><br><span class="line">-e CONFIG_CONFIGFS_FS \</span><br><span class="line">-e CONFIG_SECURITYFS \</span><br><span class="line">-e CONFIG_KCOV_ENABLE_COMPARISONS</span><br><span class="line"></span><br><span class="line"><span class="comment"># compare? CONFIG_KCOV_ENABLE_COMPARISONS=y</span></span><br><span class="line"></span><br><span class="line">make olddefconfig 		<span class="comment"># make CC=clang olddefconfig</span></span><br><span class="line"><span class="comment"># when writing output to /tmp/cct4h6sz.s no space left on device</span></span><br><span class="line">make -j`<span class="built_in">nproc</span>` <span class="comment"># make CC=clang -j`nproc`</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> -R 777 <span class="variable">$KERNEL</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ls</span> <span class="variable">$KERNEL</span>/vmlinux</span><br><span class="line"><span class="comment"># sample output - $KERNEL/vmlinux</span></span><br><span class="line"><span class="built_in">ls</span> <span class="variable">$KERNEL</span>/arch/x86/boot/bzImage</span><br><span class="line"><span class="comment"># sample output - $KERNEL/arch/x86/boot/bzImage</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># cd $KERNEL/..</span></span><br><span class="line"><span class="comment"># image</span></span><br><span class="line"><span class="built_in">sudo</span> apt install debootstrap</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> image</span><br><span class="line"><span class="built_in">cd</span> image/</span><br><span class="line"><span class="built_in">export</span> IMAGE=`<span class="built_in">pwd</span>`</span><br><span class="line">wget https://raw.githubusercontent.com/google/syzkaller/master/tools/create-image.sh -O create-image.sh</span><br><span class="line"><span class="comment"># about line:147</span></span><br><span class="line"><span class="comment"># mirrors can be found at: http://www.debian.org/misc/README.mirrors (without CN ...)</span></span><br><span class="line"><span class="comment"># seems that ubuntu also works ?</span></span><br><span class="line"><span class="comment"># sudo debootstrap $DEBOOTSTRAP_PARAMS &quot;https://mirrors.tuna.tsinghua.edu.cn/debian/&quot;</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> +x create-image.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># rm --&gt; sudo rm (about line:179)</span></span><br><span class="line">./create-image.sh --feature full --add-perf </span><br><span class="line"><span class="comment"># if create dead, `I: Base system installed successfully.`</span></span><br><span class="line"><span class="comment"># and can not remove $IMAGE</span></span><br><span class="line"><span class="comment"># cat /etc/mtab</span></span><br><span class="line"><span class="comment"># sudo umount -l $IMAGE/chroot/proc</span></span><br><span class="line"><span class="comment"># sudo umount -l $IMAGE/chroot/sys</span></span><br><span class="line"><span class="comment"># sudo rm -rf $IMAGE</span></span><br><span class="line"><span class="comment"># ========</span></span><br><span class="line"><span class="comment"># BUT, I still fail to solve this problem, it will always stop after `I: Base system installed successfully.`</span></span><br><span class="line"><span class="comment"># even I just enter `sudo ./create-image.sh` </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if `Cannot check Release signature; keyring file not available /usr/share/keyrings/debian-archive-keyring.gpg`</span></span><br><span class="line"><span class="comment"># then add `--no-check-gpg`</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># qemu</span></span><br><span class="line"><span class="built_in">sudo</span> apt install qemu-system-x86</span><br><span class="line"> </span><br><span class="line"><span class="comment"># if you are tesing in a VM (Vmware), you should open the kvm support provide by VMware.  Virtualization Engine</span></span><br><span class="line"><span class="comment"># use these command to check</span></span><br><span class="line"><span class="comment"># ls -l /dev/kvm </span></span><br><span class="line"><span class="comment"># lsmod | grep kvm</span></span><br><span class="line"><span class="comment"># verify</span></span><br><span class="line"><span class="built_in">sudo</span> qemu-system-x86_64 \</span><br><span class="line">	-m 2G \</span><br><span class="line">	-smp 2 \</span><br><span class="line">	-kernel <span class="variable">$KERNEL</span>/arch/x86/boot/bzImage \</span><br><span class="line">	-append <span class="string">&quot;console=ttyS0 root=/dev/sda earlyprintk=serial net.ifnames=0&quot;</span> \</span><br><span class="line">	-drive file=<span class="variable">$IMAGE</span>/bullseye.img,format=raw \</span><br><span class="line">	-net user,host=10.0.2.10,hostfwd=tcp:127.0.0.1:10021-:22 \</span><br><span class="line">	-net nic,model=e1000 \</span><br><span class="line">	-enable-kvm \</span><br><span class="line">	-nographic \</span><br><span class="line">	-pidfile vm.pid \</span><br><span class="line">	2&gt;&amp;1 | <span class="built_in">tee</span> vm.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># # open another terminal, and connect</span></span><br><span class="line"><span class="comment"># sudo ssh -i $IMAGE/bullseye.id_rsa -p 10021 -o &quot;StrictHostKeyChecking no&quot; root@localhost</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># exit from the qemu</span></span><br><span class="line"><span class="comment"># 1. press ctrl+a</span></span><br><span class="line"><span class="comment"># 2. then press x</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># test a prog use Syzkaller</span></span><br><span class="line">scp -P 10021 -i /home/asd/Desktop/image/bullseye.id_rsa bin/linux_amd64/syz-execprog bin/linux_amd64/syz-executor program root@localhost:</span><br><span class="line"></span><br><span class="line"><span class="comment"># https://github.com/google/syzkaller/blob/master/docs/executing_syzkaller_programs.md</span></span><br><span class="line"><span class="comment"># then you need to adjust syz-execprog flags based on the values in the header. Namely, Threaded/Procs/Sandbox directly relate to -threaded/-procs/-sandbox flags. If Repeat is set to true, add -repeat=0 flag to syz-execprog.</span></span><br><span class="line"><span class="comment"># # repro.prog --&gt; cat to program</span></span><br><span class="line"><span class="comment"># # &#123;Threaded:false Repeat:false RepeatTimes:0 Procs:1 Slowdown:1 Sandbox: SandboxArg:0 Leak:false NetInjection:false NetDevices:false NetReset:false Cgroups:false BinfmtMisc:false CloseFDs:false KCSAN:false DevlinkPCI:false NicVF:false USB:false VhciInjection:false Wifi:false IEEE802154:false Sysctl:false UseTmpDir:false HandleSegv:false Repro:false Trace:false LegacyOptions:&#123;Collide:false Fault:false FaultCall:0 FaultNth:0&#125;&#125;</span></span><br><span class="line"><span class="comment"># r0 = syz_open_dev$sg(&amp;(0x7f0000000000), 0x0, 0x0)</span></span><br><span class="line"><span class="comment"># ioctl$SG_IO(r0, 0x2285, &amp;(0x7f0000000580)=&#123;0x53, 0xfffffffffffffffc, 0x6, 0x0, @buffer=&#123;0x0, 0x1004, &amp;(0x7f0000001700)=&quot;&quot;/4100&#125;, &amp;(0x7f0000000040)=&quot;b79525bdb38d&quot;, 0x0, 0x4, 0x0, 0x0, 0x0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># so run:</span></span><br><span class="line">./syz-execprog -procs=1 -threaded=<span class="literal">false</span> -coverfile=coverfile program</span><br><span class="line"></span><br><span class="line"><span class="comment"># copy back</span></span><br><span class="line"><span class="comment"># input this command in vm, and then input password</span></span><br><span class="line"><span class="comment"># the ssh server is the target addr</span></span><br><span class="line">scp -P 22 filename asd@192.168.254.130:path_you_want_to_save</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 装 clang 疑似还有另外的教程 再看看重新整</span></span><br><span class="line"><span class="comment"># 这个人的 pass 的教程还有注释 https://blog.yuuoniy.cn/posts/llvm-pass-1/</span></span><br><span class="line"><span class="comment"># llvm</span></span><br><span class="line"><span class="comment"># 先装一个 clang11</span></span><br><span class="line"><span class="built_in">sudo</span> apt install clang-11 --install-suggests</span><br><span class="line"><span class="comment"># $ clang --version</span></span><br><span class="line"><span class="comment"># Ubuntu clang version 11.0.0-2~ubuntu20.04.1</span></span><br><span class="line"><span class="comment"># Target: x86_64-pc-linux-gnu</span></span><br><span class="line"><span class="comment"># Thread model: posix</span></span><br><span class="line"><span class="comment"># InstalledDir: /usr/bin</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后装 cmake 3.16.3</span></span><br><span class="line"><span class="built_in">sudo</span> apt install cmake</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后下载并根据这个测试 https://github.com/sampsyo/llvm-pass-skeleton</span></span><br><span class="line"><span class="comment"># 具体测试时 执行这个 $ clang -Xclang -load -Xclang build/skeleton/libSkeletonPass.* something.c</span></span><br><span class="line"><span class="comment"># -flegacy-pass-manager  不要了 不管其用处</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 编译内核时 引入我们的 pass</span></span><br><span class="line"><span class="comment"># 原本要执行的命令是 make CC=clang -j`nproc`</span></span><br><span class="line"><span class="comment"># 由于我们的 clang 引用自己的 pass 需要加很多额外的参数 clang -Xclang -load -Xclang /home/asd/Desktop/llvm-pass-skeleton/build/skeleton/libSkeletonPass.*</span></span><br><span class="line"><span class="comment"># 所以，我们简单搜索了一下 how to build kernel with pass ，然后不负众望的 stackoverflow 解决了问题</span></span><br><span class="line"><span class="comment"># https://stackoverflow.com/questions/40442218/how-to-pass-compiler-options-during-linux-kernel-compilation</span></span><br><span class="line"><span class="comment"># 在 内核的 makefile 中有这样的代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # Add user supplied CPPFLAGS, AFLAGS, CFLAGS and RUSTFLAGS as the last assignments</span></span><br><span class="line"><span class="comment"># KBUILD_CPPFLAGS += $(KCPPFLAGS)</span></span><br><span class="line"><span class="comment"># KBUILD_AFLAGS   += $(KAFLAGS)</span></span><br><span class="line"><span class="comment"># KBUILD_CFLAGS   += $(KCFLAGS)</span></span><br><span class="line"><span class="comment"># KBUILD_RUSTFLAGS += $(KRUSTFLAGS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后 make &quot;KCFLAGS=-pipe -Wsomething&quot; 就可以传递自己的自定义参数了</span></span><br><span class="line"><span class="comment"># 于是简单缝合一下  我们的 make CC=clang -j`nproc` 命令变成了 </span></span><br><span class="line">make <span class="string">&quot;KCFLAGS=-Xclang -load -Xclang /home/asd/Desktop/llvm-pass-skeleton/build/skeleton/libSkeletonPass.*&quot;</span> CC=clang -j`<span class="built_in">nproc</span>` </span><br><span class="line"></span><br><span class="line"><span class="comment"># # 然后就成功了，输出如下</span></span><br><span class="line"><span class="comment"># $ make &quot;KCFLAGS=-Xclang -load -Xclang /home/asd/Desktop/llvm-pass-skeleton/build/skeleton/libSkeletonPass.*&quot; CC=clang -j`nproc` </span></span><br><span class="line"><span class="comment">#   HOSTCC  scripts/basic/fixdep</span></span><br><span class="line"><span class="comment">#   SYSHDR  arch/x86/include/generated/uapi/asm/unistd_32.h</span></span><br><span class="line"><span class="comment">#   SYSHDR  arch/x86/include/generated/uapi/asm/unistd_64.h</span></span><br><span class="line"><span class="comment"># ......</span></span><br><span class="line"><span class="comment">#   LINK    /home/asd/Desktop/linux/tools/objtool/objtool</span></span><br><span class="line"><span class="comment">#   HOSTCC  scripts/mod/mk_elfconfig</span></span><br><span class="line"><span class="comment">#   CC      scripts/mod/empty.o</span></span><br><span class="line"><span class="comment">#   CC      scripts/mod/devicetable-offsets.s</span></span><br><span class="line"><span class="comment">#   MKELF   scripts/mod/elfconfig.h</span></span><br><span class="line"><span class="comment"># I saw a function called main!</span></span><br><span class="line"><span class="comment">#   HOSTCC  scripts/mod/modpost.o</span></span><br><span class="line"><span class="comment"># ......</span></span><br><span class="line"><span class="comment">#   CHKSHA1 include/linux/atomic/atomic-instrumented.h</span></span><br><span class="line"><span class="comment">#   CHKSHA1 include/linux/atomic/atomic-long.h</span></span><br><span class="line"><span class="comment"># I saw a function called main!</span></span><br><span class="line"><span class="comment">#   CC      arch/x86/kernel/asm-offsets.s</span></span><br><span class="line"><span class="comment"># I saw a function called main!</span></span><br><span class="line"><span class="comment"># I saw a function called common!</span></span><br><span class="line"><span class="comment">#   CALL    scripts/checksyscalls.sh</span></span><br><span class="line"><span class="comment">#   LDS     scripts/module.lds</span></span><br><span class="line"><span class="comment">#   CC      init/main.o</span></span><br><span class="line"><span class="comment">#   HOSTCC  usr/gen_init_cpio</span></span><br><span class="line"><span class="comment">#   CC      init/do_mounts.o</span></span><br><span class="line"><span class="comment">#   CC      ipc/compat.o</span></span><br><span class="line"><span class="comment">#   CC      certs/system_keyring.o</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># clang 的另外安装</span></span><br><span class="line"><span class="comment"># https://github.com/actions/runner-images/issues/2819</span></span><br><span class="line"><span class="comment"># https://ubuntu.pkgs.org/20.04/ubuntu-updates-universe-arm64/llvm-11-dev_11.0.0-2~ubuntu20.04.1_arm64.deb.html</span></span><br><span class="line"><span class="comment"># https://llvm.org/doxygen/SimplifyCFGPass_8cpp_source.html</span></span><br></pre></td></tr></table></figure>
<h1 id="0x09-参考链接"><a href="#0x09-参考链接" class="headerlink" title="0x09 参考链接"></a>0x09 参考链接</h1><p>主要参考自 Syzkaller 官方仓库，一些即时的参考链接已经在文中给出。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/f325deb023e4e2fb9197004be1b3da738680429c/docs/setup.md">How to install syzkaller</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/f325deb023e4e2fb9197004be1b3da738680429c/docs/usage.md">How to use syzkaller</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/f325deb023e4e2fb9197004be1b3da738680429c/docs/internals.md">How syzkaller works</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Ron</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lucxer.tech/2023/02/13/34.Syzkaller/">https://lucxer.tech/2023/02/13/34.Syzkaller/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lucxer.tech" target="_blank">Ron's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Fuzz/">Fuzz</a><a class="post-meta__tags" href="/tags/Syzkaller/">Syzkaller</a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=5fb3e45d5f9ff11c" async="async"></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/wechat.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/10/35.kcov%E4%B8%8E%E5%88%86%E6%9E%90/"><img class="prev-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/qriosa/picgo-blog/img/kcov-mhtf.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Syzkaller 中用到 kcov 记录覆盖分析</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/25/33.HEALER/"><img class="next-cover" data-lazy-src="https://kiprey.github.io/2021/11/healer/image-20211129200131315.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">论文Healer分析和复现</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/04/10/35.kcov与分析/" title="Syzkaller 中用到 kcov 记录覆盖分析"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/gh/qriosa/picgo-blog/img/kcov-mhtf.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-10</div><div class="title">Syzkaller 中用到 kcov 记录覆盖分析</div></div></a></div><div><a href="/2023/01/25/33.HEALER/" title="论文Healer分析和复现"><img class="cover" data-lazy-src="https://kiprey.github.io/2021/11/healer/image-20211129200131315.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-25</div><div class="title">论文Healer分析和复现</div></div></a></div><div><a href="/2022/12/23/32.LLVM及clang入门/" title="LLVM及clang入门"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/gh/qriosa/picgo-blog/img/llvm_logo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-23</div><div class="title">LLVM及clang入门</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Ron</div><div class="author-info__description">(retired) OI/Crypto, Fuzzing</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">68</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/qriosa"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/qriosa" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:chegnxiang@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">号外！号外！评论系统已开放！</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x00-%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-number">1.</span> <span class="toc-text">0x00 写在前面</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x01-coverage-%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">0x01 coverage 检测方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Binutils"><span class="toc-number">2.1.</span> <span class="toc-text">Binutils</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#readelf"><span class="toc-number">2.1.1.</span> <span class="toc-text">readelf</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reporting-coverage-data"><span class="toc-number">2.2.</span> <span class="toc-text">Reporting coverage data</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nm"><span class="toc-number">2.2.1.</span> <span class="toc-text">nm</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-Dump-and-Symbolize"><span class="toc-number">2.3.</span> <span class="toc-text">Object Dump and Symbolize</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#objdump"><span class="toc-number">2.3.1.</span> <span class="toc-text">objdump</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addr2line"><span class="toc-number">2.3.2.</span> <span class="toc-text">addr2line</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Create-report"><span class="toc-number">2.4.</span> <span class="toc-text">Create report</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x02-go-func-amp-feature"><span class="toc-number">3.</span> <span class="toc-text">0x02 go func &amp; feature</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#r-Intn-n"><span class="toc-number">3.1.</span> <span class="toc-text">r.Intn(n)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#r-oneOf-n"><span class="toc-number">3.2.</span> <span class="toc-text">r.oneOf(n)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#r-nOutOf-n-oufOf"><span class="toc-number">3.3.</span> <span class="toc-text">r.nOutOf(n, oufOf)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#r-biasedRand-n-k"><span class="toc-number">3.4.</span> <span class="toc-text">r. biasedRand(n, k)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sort-Search-int-func"><span class="toc-number">3.5.</span> <span class="toc-text">Sort.Search(int, func)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch"><span class="toc-number">3.6.</span> <span class="toc-text">switch</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x03-mutation-%E8%A7%84%E5%88%99"><span class="toc-number">4.</span> <span class="toc-text">0x03 mutation 规则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E5%BC%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">变异模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%8F%98%E5%BC%82%E8%BF%87%E7%A8%8B"><span class="toc-number">4.2.</span> <span class="toc-text">具体变异过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mutateArg-%E8%A7%84%E5%88%99"><span class="toc-number">4.2.1.</span> <span class="toc-text">mutateArg 规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#squashAny-%E8%A7%84%E5%88%99"><span class="toc-number">4.2.2.</span> <span class="toc-text">squashAny 规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%8F%98%E5%BC%82%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">4.3.</span> <span class="toc-text">参数变异优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E5%BC%82%E8%A7%84%E5%88%99%E6%8C%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.4.</span> <span class="toc-text">变异规则按类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mutateInt"><span class="toc-number">4.4.1.</span> <span class="toc-text">mutateInt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mutateAlignedInt"><span class="toc-number">4.4.2.</span> <span class="toc-text">mutateAlignedInt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#t-IntType-mutate"><span class="toc-number">4.4.3.</span> <span class="toc-text">(t *IntType) mutate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#t-FlagsType-mutate"><span class="toc-number">4.4.4.</span> <span class="toc-text">(t *FlagsType) mutate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#t-LenType-mutate"><span class="toc-number">4.4.5.</span> <span class="toc-text">(t *LenType) mutate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#t-ResourceType-VmaType-ProcType-mutate"><span class="toc-number">4.4.6.</span> <span class="toc-text">(t ResourceType&#x2F;\VmaType&#x2F;*ProcType) mutate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#t-BufferType-mutate"><span class="toc-number">4.4.7.</span> <span class="toc-text">(t *BufferType) mutate</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8F%98%E5%BC%82%E5%87%BD%E6%95%B0"><span class="toc-number">4.5.</span> <span class="toc-text">数据变异函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#syz-fuzzer"><span class="toc-number">4.6.</span> <span class="toc-text">syz-fuzzer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ipc"><span class="toc-number">4.7.</span> <span class="toc-text">ipc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E6%94%B6%E9%9B%86"><span class="toc-number">4.8.</span> <span class="toc-text">覆盖收集</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x04-cov-web-%E7%9A%84%E6%9F%A5%E7%9C%8B"><span class="toc-number">5.</span> <span class="toc-text">0x04 cov web 的查看</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DoHTML"><span class="toc-number">5.1.</span> <span class="toc-text">DoHTML</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#processDir"><span class="toc-number">5.2.</span> <span class="toc-text">processDir</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-number">5.3.</span> <span class="toc-text">实例分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%8E%87%E5%88%86%E6%9E%90"><span class="toc-number">5.3.1.</span> <span class="toc-text">覆盖率分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E7%9C%8B"><span class="toc-number">5.3.2.</span> <span class="toc-text">源码分析与查看</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x05-%E6%89%A7%E8%A1%8C-prog"><span class="toc-number">6.</span> <span class="toc-text">0x05 执行 prog</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x06-Crash"><span class="toc-number">7.</span> <span class="toc-text">0x06 Crash</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x07-%E5%AE%9E%E9%99%85%E7%BC%96%E8%AF%91%E6%B5%8B%E8%AF%95"><span class="toc-number">8.</span> <span class="toc-text">0x07 实际编译测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-6-22"><span class="toc-number">8.1.</span> <span class="toc-text">Linux-6.22</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x08-%E4%B8%80%E4%BA%9B%E8%BF%87%E7%A8%8B%E5%91%BD%E4%BB%A4%E8%84%9A%E6%9C%AC"><span class="toc-number">9.</span> <span class="toc-text">0x08 一些过程命令脚本</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x09-%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">10.</span> <span class="toc-text">0x09 参考链接</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/11/19/39.CVE-2024-2961%20%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%BF%87%E7%A8%8B/" title="CVE-2024-2961 调试复现分析"><img data-lazy-src="https://cdn.jsdelivr.net/gh/qriosa/picgo-blog/img/CVE-2024-2961-heap-page.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CVE-2024-2961 调试复现分析"/></a><div class="content"><a class="title" href="/2024/11/19/39.CVE-2024-2961%20%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%BF%87%E7%A8%8B/" title="CVE-2024-2961 调试复现分析">CVE-2024-2961 调试复现分析</a><time datetime="2024-11-19T13:12:11.000Z" title="发表于 2024-11-19 21:12:11">2024-11-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/18/38.CVE-2018-1160%20%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/" title="CVE-2018-1160 调试复现分析"><img data-lazy-src="https://cdn.jsdelivr.net/gh/qriosa/picgo-blog/img/CVE-2018-1160-control_flow_hijack_chart.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CVE-2018-1160 调试复现分析"/></a><div class="content"><a class="title" href="/2023/10/18/38.CVE-2018-1160%20%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/" title="CVE-2018-1160 调试复现分析">CVE-2018-1160 调试复现分析</a><time datetime="2023-10-18T12:42:19.000Z" title="发表于 2023-10-18 20:42:19">2023-10-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/21/37.CVE-2021-30145%20%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/" title="CVE-2021-30145 调试复现分析"><img data-lazy-src="https://cdn.jsdelivr.net/gh/qriosa/picgo-blog/img/CVE-2021-30145-process.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CVE-2021-30145 调试复现分析"/></a><div class="content"><a class="title" href="/2023/09/21/37.CVE-2021-30145%20%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/" title="CVE-2021-30145 调试复现分析">CVE-2021-30145 调试复现分析</a><time datetime="2023-09-21T04:11:11.000Z" title="发表于 2023-09-21 12:11:11">2023-09-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/12/36.CVE-2018-6789%20%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/" title="CVE-2018-6789 调试复现分析"><img data-lazy-src="https://cdn.jsdelivr.net/gh/qriosa/picgo-blog/img/CVE-2018-6789-process.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CVE-2018-6789 调试复现分析"/></a><div class="content"><a class="title" href="/2023/08/12/36.CVE-2018-6789%20%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/" title="CVE-2018-6789 调试复现分析">CVE-2018-6789 调试复现分析</a><time datetime="2023-08-12T13:12:41.000Z" title="发表于 2023-08-12 21:12:41">2023-08-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/10/35.kcov%E4%B8%8E%E5%88%86%E6%9E%90/" title="Syzkaller 中用到 kcov 记录覆盖分析"><img data-lazy-src="https://cdn.jsdelivr.net/gh/qriosa/picgo-blog/img/kcov-mhtf.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Syzkaller 中用到 kcov 记录覆盖分析"/></a><div class="content"><a class="title" href="/2023/04/10/35.kcov%E4%B8%8E%E5%88%86%E6%9E%90/" title="Syzkaller 中用到 kcov 记录覆盖分析">Syzkaller 中用到 kcov 记录覆盖分析</a><time datetime="2023-04-10T14:12:12.000Z" title="发表于 2023-04-10 22:12:12">2023-04-10</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Ron</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to <a href="https://lucxer.tech">Ron's home</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.spacingElementById('content-inner')
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.spacingElementById('content-inner')
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/algolia.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: 'kvdp8zac8n33pNjoPPrELp1b-MdYXbMMI',
      appKey: 't7PV1NwrBX5XxIJWIt4SBNak',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick'.split(','))
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign({}, initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config_change',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  if (typeof gtag === 'function') {
    gtag('config', '', {'page_path': window.location.pathname});
  }

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})


document.addEventListener('pjax:send', function () {
  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})</script><script>(function(){
  const bp = document.createElement('script');
  const curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  bp.dataset.pjax = ''
  const s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})()</script></div></body></html>